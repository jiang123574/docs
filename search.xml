<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git记录</title>
    <url>/git%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>常用操作：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add . 或某个文件，某些文件</span><br><span class="line">git commit -m <span class="string">'fix '</span> 提交信息</span><br><span class="line">git status 查看当前版本库状态</span><br><span class="line">git diff 文件 1 文件 2   对文件进行比较（也可在版本之间进行比较，后面文件均替换为版本号） </span><br><span class="line">git push 推送</span><br><span class="line">git pull 拉取</span><br><span class="line">git merge 合并指定分支到当前分支</span><br><span class="line">git checkout +文件，表示  撤销对某文件的修改; + 分支，表示切换分支</span><br><span class="line">git rm 文件  删除某文件</span><br><span class="line">git <span class="built_in">clone</span> 克隆</span><br><span class="line">git checkout -b +分支，表示创建新分支（非 master 分支）</span><br><span class="line">git branch 查看当前分支； + -a 表示查看所有分支 </span><br><span class="line">git branch -d +分支 删除某分支</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>日志：<br>日志查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log：</span><br><span class="line">		查看某分支当前的版本号</span><br></pre></td></tr></table></figure>


<p>操作日志查询：</p>
<pre><code>可以查看某分支自己之前执行过什么操作。</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reflog：</span><br></pre></td></tr></table></figure>

<p>工作区及暂存区<br>    工作区就是存有.git 文件夹的父文件夹，暂存区是在.git 文件夹里的区域。<br>我们执行的 git add [.]就是把文件从工作区添加到了暂存区(stage)中，而 git commit 就是把暂存区里的东西提交到当前的本地分支比如 test 分支，工作区就变干净了。<br>远程仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">添加远程仓库 git remote add origin + 远程 git 地址 (例如 git@github.com:1900/reviewgit.git)</span><br></pre></td></tr></table></figure>

<p>分支管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个分支就是创建一个指针，该指针指向 master 的某个节点，另外会有 head 指针来负责分支切换。具体指令在文章起始部分。</span><br></pre></td></tr></table></figure>

<p>冲突解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">黄金准则是：有冲突解决冲突，而不要直接就回滚，因为代码库不是你一个人在用！</span><br><span class="line"></span><br><span class="line">操作就是，打开冲突文件，搜索 &gt;&gt;&gt;&gt;&gt;标识确定冲突部分，删除不想要的内容，删除&gt;&gt;&gt;&gt;  及 ====，然后 git add 文件，提交。</span><br></pre></td></tr></table></figure>

<p>bug 分支<br>并发的处理了两个问题，问题 1 需要尽快提交解决线上问题，问题 2 还没搞定，这个时候可以利用 stash 功能来暂存。git stash,接着解决问题 1，在当前分支创建一个临时分支，然后修改问题，并提交。</p>
]]></content>
  </entry>
  <entry>
    <title>使用transmission制作PT种子</title>
    <url>/%E4%BD%BF%E7%94%A8transmission%E5%88%B6%E4%BD%9CPT%E7%A7%8D%E5%AD%90/</url>
    <content><![CDATA[<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/volume1/@appstore/transmission/bin/transmission-create -p -o /volume2/video/电视剧/Mindhunter.S02.1080p.NF.WEB-DL.DDP5.1.x264-MZABI.torrent -t http://hdhome.org/announce.php -s 2048 /volume2/video/电视剧/Mindhunter.S02.1080p.NF.WEB-DL.DDP5.1.x264-MZABI</span><br></pre></td></tr></table></figure><a id="more"></a>

<p>参数<br>-p 表示这是私用的种子，这个必须要加上<br>-o 生成的种子输出位置，不要忘记把名字打上<br>-t tracker的地址，我用的家园的做范本，大家自行修改<br>-s 每个文件块的大小，单位是KB，我设置的是2M，也就是2048KB</p>
]]></content>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>引用自<strong>骆昊</strong><a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python - 100天从新手到大师</a><br>关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫<a href="https://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">《正则表达式30分钟入门教程》</a>，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。</p>
</blockquote><a id="more"></a>
<table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配任意字符</td>
<td>b.t</td>
<td>可以匹配bat / but / b#t / b1t等</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母/数字/下划线</td>
<td>b\wt</td>
<td>可以匹配bat / b1t / b_t等<br>但不能匹配b#t</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空白字符（包括\r、\n、\t等）</td>
<td>love\syou</td>
<td>可以匹配love you</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
<td>\d\d</td>
<td>可以匹配01 / 23 / 99等</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的边界</td>
<td>\bThe\b</td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
<td>^The</td>
<td>可以匹配The开头的字符串</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
<td>.exe$</td>
<td>可以匹配.exe结尾的字符串</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母/数字/下划线</td>
<td>b\Wt</td>
<td>可以匹配b#t / b@t等<br>但不能匹配but / b1t / b_t等</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空白字符</td>
<td>love\Syou</td>
<td>可以匹配love#you等<br>但不能匹配love you</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字</td>
<td>\d\D</td>
<td>可以匹配9a / 3# / 0F等</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界</td>
<td>\Bio\B</td>
<td></td>
</tr>
<tr>
<td>[]</td>
<td>匹配来自字符集的任意单一字符</td>
<td>[aeiou]</td>
<td>可以匹配任一元音字母字符</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不在字符集中的任意单一字符</td>
<td>[^aeiou]</td>
<td>可以匹配任一非元音字母字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0次或多次</td>
<td>\w*</td>
<td></td>
</tr>
<tr>
<td>+</td>
<td>匹配1次或多次</td>
<td>\w+</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>匹配0次或1次</td>
<td>\w?</td>
<td></td>
</tr>
<tr>
<td>{N}</td>
<td>匹配N次</td>
<td>\w{3}</td>
<td></td>
</tr>
<tr>
<td>{M,}</td>
<td>匹配至少M次</td>
<td>\w{3,}</td>
<td></td>
</tr>
<tr>
<td>{M,N}</td>
<td>匹配至少M次至多N次</td>
<td>\w{3,6}</td>
<td></td>
</tr>
<tr>
<td>|</td>
<td>分支</td>
<td>foo|bar</td>
<td>可以匹配foo或者bar</td>
</tr>
<tr>
<td>(?#)</td>
<td>注释</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(exp)</td>
<td>匹配exp并捕获到自动命名的组中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?&nbsp;&lt;name&gt;exp)</td>
<td>匹配exp并捕获到名为name的组中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?:exp)</td>
<td>匹配exp但是不捕获匹配的文本</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?=exp)</td>
<td>匹配exp前面的位置</td>
<td>\b\w+(?=ing)</td>
<td>可以匹配I’m dancing中的danc</td>
</tr>
<tr>
<td>(?&lt;=exp)</td>
<td>匹配exp后面的位置</td>
<td>(?&lt;=\bdanc)\w+\b</td>
<td>可以匹配I love dancing and reading中的第一个ing</td>
</tr>
<tr>
<td>(?!exp)</td>
<td>匹配后面不是exp的位置</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?&lt;!exp)</td>
<td>匹配前面不是exp的位置</td>
<td></td>
<td></td>
</tr>
<tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
<td>a.*b<br>a.*?b</td>
<td>将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或多次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>{M,N}?</td>
<td>重复M到N次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>{M,}?</td>
<td>重复M次以上，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明：</strong> 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则圆括号被视为正则表达式中的分组。</p>
</blockquote>
<h3 id="Python对正则表达式的支持"><a href="#Python对正则表达式的支持" class="headerlink" title="Python对正则表达式的支持"></a>Python对正则表达式的支持</h3><p>Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>compile(pattern, flags=0)</td>
<td>编译正则表达式返回正则表达式对象</td>
</tr>
<tr>
<td>match(pattern, string, flags=0)</td>
<td>用正则表达式匹配字符串 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>search(pattern, string, flags=0)</td>
<td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>split(pattern, string, maxsplit=0, flags=0)</td>
<td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td>
</tr>
<tr>
<td>sub(pattern, repl, string, count=0, flags=0)</td>
<td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数</td>
</tr>
<tr>
<td>fullmatch(pattern, string, flags=0)</td>
<td>match函数的完全匹配（从字符串开头到结尾）版本</td>
</tr>
<tr>
<td>findall(pattern, string, flags=0)</td>
<td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td>
</tr>
<tr>
<td>finditer(pattern, string, flags=0)</td>
<td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td>
</tr>
<tr>
<td>purge()</td>
<td>清除隐式编译的正则表达式的缓存</td>
</tr>
<tr>
<td>re.I / re.IGNORECASE</td>
<td>忽略大小写匹配标记</td>
</tr>
<tr>
<td>re.M / re.MULTILINE</td>
<td>多行匹配标记</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字</span></span><br><span class="line">    pattern = re.compile(<span class="string">r'(?&lt;=\D)1[34578]\d&#123;9&#125;(?=\D)'</span>)</span><br><span class="line">    sentence = <span class="string">'''</span></span><br><span class="line"><span class="string">    重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，</span></span><br><span class="line"><span class="string">    不是15600998765，也是110或119，王大锤的手机号才是15600998765。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 查找所有匹配并保存到一个列表中</span></span><br><span class="line">    mylist = re.findall(pattern, sentence)</span><br><span class="line">    print(mylist)</span><br><span class="line">    print(<span class="string">'--------华丽的分隔线--------'</span>)</span><br><span class="line">    <span class="comment"># 通过迭代器取出匹配对象并获得匹配的内容</span></span><br><span class="line">    <span class="keyword">for</span> temp <span class="keyword">in</span> pattern.finditer(sentence):</span><br><span class="line">        print(temp.group())</span><br><span class="line">    print(<span class="string">'--------华丽的分隔线--------'</span>)</span><br><span class="line">    <span class="comment"># 通过search函数指定搜索位置找出所有匹配</span></span><br><span class="line">    m = pattern.search(sentence)</span><br><span class="line">    <span class="keyword">while</span> m:</span><br><span class="line">        print(m.group())</span><br><span class="line">        m = pattern.search(sentence, m.end())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas学习笔记</title>
    <url>/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>数据库操作</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">engine=create_engine(<span class="string">"mysql+pymysql://root:password@127.0.0.1:3306/&lt;sqldata&gt;?charset=utf8"</span>,pool_timeout=<span class="number">30</span>) <span class="comment">#连接数据库  pool_timeout：连接超时 sqldata:数据库名称</span></span><br><span class="line">pd.read_sql(<span class="string">'select * from &lt;sqldata&gt;'</span>,engine,index_col=<span class="string">'a'</span>) <span class="comment">#读取数据库 index_col：索引列 &lt;sqldata&gt;:数据库表名</span></span><br><span class="line">con = engine.connect() <span class="comment">#创建数据库指针</span></span><br><span class="line">pd.to_sql(name=<span class="string">'sqldata'</span>, con=con, if_exists=<span class="string">'append'</span>, index=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#name:输出表名 </span></span><br><span class="line"><span class="comment">#con: 数据库连接 </span></span><br><span class="line"><span class="comment">#if_exists：操作方式（fail:若表存在，则不输出,replace：若表存在，覆盖原来表里的数据append：若表存在，将数据写到原表的后面）</span></span><br><span class="line"><span class="comment">#index:是否将df的index单独写到一列中(False,True)</span></span><br><span class="line"><span class="comment">#index_label:指定列作为df的index输出，此时index为True</span></span><br><span class="line"><span class="comment">#dtype: 指定列的输出到数据库中的数据类型。字典形式储存：&#123;column_name: sql_dtype&#125;。常见的数据类型有sqlalchemy.types.INTEGER(), sqlalchemy.types.NVARCHAR(),sqlalchemy.Datetime()等，具体数据类型可以参考http://docs.sqlalchemy.org/en/latest/core/type_basics.html#sql-standard-and-multiple-vendor-types</span></span><br><span class="line">engine.dispose() <span class="comment">#关闭连接</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p><strong>excel操作</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.read_excel（io，sheet_name = <span class="number">0</span>，header = <span class="number">0</span>，names = <span class="literal">None</span>，index_col = <span class="literal">None</span>，usecols = <span class="literal">None</span>，squeeze = <span class="literal">False</span>,dtype = <span class="literal">None</span>, ...）</span><br><span class="line"><span class="comment">#io:文件路径</span></span><br><span class="line"><span class="comment">#sheet_name:sheet_name=0,sheet_name=“Sheet1”,sheet_name=[0,1,'Sheet5']</span></span><br><span class="line"><span class="comment">#header：指定作为列名的行,默认0，即取第一行的值为列名。数据为列名行以下的数据；若数据不含列名，则设定 header = None。</span></span><br><span class="line"><span class="comment">#names：默认为None，要使用的列名列表，如不包含标题行，应显示传递header=None。</span></span><br><span class="line"><span class="comment">#index_col：指定列为索引列，默认None列（0索引）用作DataFrame的行标签。</span></span><br><span class="line"><span class="comment">#usecols：int或list，默认为None。</span></span><br><span class="line"><span class="comment">##如果为None则解析所有列</span></span><br><span class="line"><span class="comment">##如果为int则表示要解析的最后一列</span></span><br><span class="line"><span class="comment">##如果为int列表则表示要解析的列号列表</span></span><br><span class="line"><span class="comment">##如果字符串则表示以逗号分隔的Excel列字母和列范围列表（例如“A：E”或“A，C，E：F”）。范围包括双方。</span></span><br><span class="line"><span class="comment">#squeeze：boolean，默认为False,如果解析的数据只包含一列，则返回一个Series。</span></span><br><span class="line"><span class="comment">#skiprows：省略指定行数的数据,从第一行开始。</span></span><br><span class="line"><span class="comment">#skipfooter：省略指定行数的数据，从尾部数的行开始。</span></span><br><span class="line"><span class="comment">#dtype:字典类型&#123;'列名1':数据类型，‘列名’:数据类型&#125;，设定指定列的数据类型。</span></span><br></pre></td></tr></table></figure>

<p><strong>对于时间序列的一些操作</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">x=pd.DataFrame(&#123;<span class="string">'date'</span>:[<span class="string">'2016-01-20'</span>,<span class="string">'2016-01-30'</span>,<span class="string">'2016-02-25'</span>,<span class="string">'2016-03-05'</span>]&#125;,index=[<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>])</span><br><span class="line">x[<span class="string">'date'</span>]=x[<span class="string">'date'</span>].astype(<span class="string">'datetime64'</span>) <span class="comment">#转换数据类型</span></span><br><span class="line">x[<span class="string">'date'</span>].dt.week <span class="comment">#计算第几周</span></span><br><span class="line">pd.Timestamp.now() <span class="comment">#现在时间</span></span><br><span class="line">pd.Timedelta(days=<span class="number">4</span>) <span class="comment">#创建一个时间长度</span></span><br><span class="line">pd.Timestamp(<span class="string">'2019-08-15'</span>) <span class="comment">#创建一个时间</span></span><br></pre></td></tr></table></figure>

<p><strong>索引</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">'a'</span>]  <span class="comment">#默认为列索引</span></span><br><span class="line">df.loc[<span class="string">'a'</span>] <span class="comment">#行索引</span></span><br><span class="line">df.iloc[<span class="number">2</span>] <span class="comment">#行索引</span></span><br><span class="line">df.loc[:,<span class="string">'a'</span>] <span class="comment">#列索引</span></span><br><span class="line">df.loc[df.A=<span class="number">1</span>,<span class="string">'a'</span>] <span class="comment">#布尔索引行后索引列</span></span><br><span class="line">df[df.a.isin(s)] <span class="comment">#索引a列中含s数据的行</span></span><br><span class="line">df[~df.a.isin(s)] <span class="comment">#索引a列中不含s数据的行</span></span><br><span class="line">df.reset_index() <span class="comment">#还原索引</span></span><br><span class="line">df.columns=[<span class="string">'a'</span>,<span class="string">'b'</span>] <span class="comment">#重新命名列索引</span></span><br><span class="line">df.index=[<span class="string">'a'</span>,<span class="string">'b'</span>] <span class="comment">#重新命名行索引</span></span><br><span class="line">df.drop([<span class="string">'a'</span>]) <span class="comment">#删除行，使用axis=1参数，删除列</span></span><br><span class="line">df.a.unique() <span class="comment">#唯一值</span></span><br></pre></td></tr></table></figure>

<p><strong>多层索引</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">arrays = [[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'red'</span>, <span class="string">'blue'</span>]]</span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">y=pd.MultiIndex.from_arrays(arrays,names=[<span class="string">'num'</span>,<span class="string">'c'</span>]) <span class="comment">#</span></span><br><span class="line">pd.MultiIndex.from_product([[<span class="string">"A"</span>,<span class="string">"B"</span>],[<span class="string">'x1'</span>,<span class="string">'y1'</span>]],names=[<span class="string">"class1"</span>,<span class="string">"class2"</span>]) <span class="comment">#从笛卡尔积创建Multilndex对象</span></span><br><span class="line">pd.DataFrame(x,y).T</span><br></pre></td></tr></table></figure>

<p><strong>分组</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>DataFrame连接</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1=pd.DataFrame(&#123;<span class="string">'款号'</span>:[<span class="string">'818009'</span>],<span class="string">'数量'</span>:[<span class="number">20</span>]&#125;)</span><br><span class="line">df2=pd.DataFrame(&#123;<span class="string">'款号'</span>:[<span class="string">'818009'</span>],<span class="string">'大类'</span>:[<span class="string">'xx'</span>],<span class="string">'小类'</span>:[<span class="string">'cc'</span>]&#125;)</span><br><span class="line">pd.merge(df2,df1,on=<span class="string">'款号'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>操作元素</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=<span class="keyword">lambda</span> a: a.upper()</span><br><span class="line">df[<span class="string">'x'</span>]=df[<span class="string">'x'</span>].map(a)</span><br><span class="line">df=df.applymap(a) <span class="comment">#操作每个元素</span></span><br><span class="line">df=df.apply(a) <span class="comment">#操作一行或者一列（使用参数 axis）</span></span><br></pre></td></tr></table></figure>

<p><strong>重复数据</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.duplicated() <span class="comment">#重复值的布尔数组</span></span><br><span class="line">df.drop_duplicates() <span class="comment">#删除重复值</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python进行数据分析</title>
    <url>/%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.bk/</url>
    <content><![CDATA[<h2 id="第-1-章-准备工作"><a href="#第-1-章-准备工作" class="headerlink" title="第 1 章 准备工作"></a>第 1 章 准备工作</h2><h3 id="1-1-本书内容"><a href="#1-1-本书内容" class="headerlink" title="1.1 本书内容"></a>1.1 本书内容</h3><h4 id="1-1-1-什么类型的数据"><a href="#1-1-1-什么类型的数据" class="headerlink" title="1.1.1 什么类型的数据"></a>1.1.1 什么类型的数据</h4><h3 id="1-2-为何利用-Python-进行数据分析"><a href="#1-2-为何利用-Python-进行数据分析" class="headerlink" title="1.2 为何利用 Python 进行数据分析"></a>1.2 为何利用 Python 进行数据分析</h3><a id="more"></a><h4 id="1-2-1-Python作为胶水"><a href="#1-2-1-Python作为胶水" class="headerlink" title="1.2.1 Python作为胶水"></a>1.2.1 Python作为胶水</h4><h4 id="1-2-2-解决“双语言”难题"><a href="#1-2-2-解决“双语言”难题" class="headerlink" title="1.2.2 解决“双语言”难题"></a>1.2.2 解决“双语言”难题</h4><h4 id="1-2-3-为何不使用-Python"><a href="#1-2-3-为何不使用-Python" class="headerlink" title="1.2.3 为何不使用 Python"></a>1.2.3 为何不使用 Python</h4><h3 id="1-3-重要的-Python库"><a href="#1-3-重要的-Python库" class="headerlink" title="1.3 重要的 Python库"></a>1.3 重要的 Python库</h3><h2 id="第-2-章"><a href="#第-2-章" class="headerlink" title="第 2 章"></a>第 2 章</h2><h2 id="第-3-章"><a href="#第-3-章" class="headerlink" title="第 3 章"></a>第 3 章</h2><h2 id="第-4-章"><a href="#第-4-章" class="headerlink" title="第 4 章"></a>第 4 章</h2><h2 id="第-5-章"><a href="#第-5-章" class="headerlink" title="第 5 章"></a>第 5 章</h2><h3 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h3><h4 id="5-1-1"><a href="#5-1-1" class="headerlink" title="5.1.1"></a>5.1.1</h4><h4 id="5-1-2"><a href="#5-1-2" class="headerlink" title="5.1.2"></a>5.1.2</h4><h4 id="5-1-3-索引对象"><a href="#5-1-3-索引对象" class="headerlink" title="5.1.3 索引对象"></a>5.1.3 索引对象</h4><p>表5-2：一些索引对象的方法和属性</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">append</td>
<td align="left">将额外的索引对象粘贴到原索引后，产生一个新的索引</td>
</tr>
<tr>
<td align="left">difference</td>
<td align="left">计算两个索引的差集</td>
</tr>
<tr>
<td align="left">intersection</td>
<td align="left">计算两个索引的交集</td>
</tr>
<tr>
<td align="left">union</td>
<td align="left">计算两个索引的并集</td>
</tr>
<tr>
<td align="left">isin</td>
<td align="left">计算表示每一个值是否在传值容器中的布尔数组</td>
</tr>
<tr>
<td align="left">delete</td>
<td align="left">键位置i的元素删除，并产生新的索引</td>
</tr>
<tr>
<td align="left">drop</td>
<td align="left">根据传参删除指定索引值，并产生新的索引</td>
</tr>
<tr>
<td align="left">insert</td>
<td align="left">在位置i插入元素，并产生新的索引</td>
</tr>
<tr>
<td align="left">is_monotonic</td>
<td align="left">如果索引序列递增则返回True</td>
</tr>
<tr>
<td align="left">is_unique</td>
<td align="left">如果索引序列唯一则返回True</td>
</tr>
<tr>
<td align="left">unique</td>
<td align="left">计算索引的唯一值序列</td>
</tr>
</tbody></table>
<h2 id="第-6-章-数据载入、存储及文件格式"><a href="#第-6-章-数据载入、存储及文件格式" class="headerlink" title="第 6 章 数据载入、存储及文件格式"></a>第 6 章 数据载入、存储及文件格式</h2><h3 id="6-1-文本格式数据的读写"><a href="#6-1-文本格式数据的读写" class="headerlink" title="6.1 文本格式数据的读写"></a>6.1 文本格式数据的读写</h3><h4 id="6-1-1"><a href="#6-1-1" class="headerlink" title="6.1.1"></a>6.1.1</h4><h4 id="6-1-2"><a href="#6-1-2" class="headerlink" title="6.1.2"></a>6.1.2</h4><h4 id="6-1-3"><a href="#6-1-3" class="headerlink" title="6.1.3"></a>6.1.3</h4><h4 id="6-1-4"><a href="#6-1-4" class="headerlink" title="6.1.4"></a>6.1.4</h4><h4 id="6-1-5"><a href="#6-1-5" class="headerlink" title="6.1.5"></a>6.1.5</h4><h3 id="6-2-二进制格式"><a href="#6-2-二进制格式" class="headerlink" title="6.2 二进制格式"></a>6.2 二进制格式</h3><h4 id="6-2-1-使用-HDF5-格式"><a href="#6-2-1-使用-HDF5-格式" class="headerlink" title="6.2.1 使用 HDF5 格式"></a>6.2.1 使用 HDF5 格式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_hdf(<span class="string">'./x.h5'</span>,<span class="string">'key'</span>)</span><br><span class="line">pd.read_hdf(<span class="string">'./x.h5'</span>,<span class="string">'key'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-读取Microsoft-Excel-文件"><a href="#6-2-2-读取Microsoft-Excel-文件" class="headerlink" title="6.2.2 读取Microsoft Excel 文件"></a>6.2.2 读取Microsoft Excel 文件</h4><p>excel操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.read_excel（io，sheet_name = <span class="number">0</span>，header = <span class="number">0</span>，names = <span class="literal">None</span>，index_col = <span class="literal">None</span>，usecols = <span class="literal">None</span>，squeeze = <span class="literal">False</span>,dtype = <span class="literal">None</span>, ...）</span><br><span class="line"><span class="comment">#io:文件路径</span></span><br><span class="line"><span class="comment">#sheet_name:sheet_name=0,sheet_name=“Sheet1”,sheet_name=[0,1,'Sheet5']</span></span><br><span class="line"><span class="comment">#header：指定作为列名的行,默认0，即取第一行的值为列名。数据为列名行以下的数据；若数据不含列名，则设定 header = None。</span></span><br><span class="line"><span class="comment">#names：默认为None，要使用的列名列表，如不包含标题行，应显示传递header=None。</span></span><br><span class="line"><span class="comment">#index_col：指定列为索引列，默认None列（0索引）用作DataFrame的行标签。</span></span><br><span class="line"><span class="comment">#usecols：int或list，默认为None。</span></span><br><span class="line"><span class="comment">##如果为None则解析所有列</span></span><br><span class="line"><span class="comment">##如果为int则表示要解析的最后一列</span></span><br><span class="line"><span class="comment">##如果为int列表则表示要解析的列号列表</span></span><br><span class="line"><span class="comment">##如果字符串则表示以逗号分隔的Excel列字母和列范围列表（例如“A：E”或“A，C，E：F”）。范围包括双方。</span></span><br><span class="line"><span class="comment">#squeeze：boolean，默认为False,如果解析的数据只包含一列，则返回一个Series。</span></span><br><span class="line"><span class="comment">#skiprows：省略指定行数的数据,从第一行开始。</span></span><br><span class="line"><span class="comment">#skipfooter：省略指定行数的数据，从尾部数的行开始。</span></span><br><span class="line"><span class="comment">#dtype:字典类型&#123;'列名1':数据类型，‘列名’:数据类型&#125;，设定指定列的数据类型。</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-与Web-API-交互"><a href="#6-3-与Web-API-交互" class="headerlink" title="6.3 与Web API 交互"></a>6.3 与Web API 交互</h3><h3 id="6-4-与数据库交互"><a href="#6-4-与数据库交互" class="headerlink" title="6.4 与数据库交互"></a>6.4 与数据库交互</h3><p>数据库操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">engine=create_engine(<span class="string">"mysql+pymysql://root:password@127.0.0.1:3306/&lt;sqldata&gt;?charset=utf8"</span>,pool_timeout=<span class="number">30</span>) <span class="comment">#连接数据库  pool_timeout：连接超时 sqldata:数据库名称</span></span><br><span class="line">pd.read_sql(<span class="string">'select * from &lt;sqldata&gt;'</span>,engine,index_col=<span class="string">'a'</span>) <span class="comment">#读取数据库 index_col：索引列 &lt;sqldata&gt;:数据库表名</span></span><br><span class="line">con = engine.connect() <span class="comment">#创建数据库指针</span></span><br><span class="line">pd.to_sql(name=<span class="string">'sqldata'</span>, con=con, if_exists=<span class="string">'append'</span>, index=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#name:输出表名</span></span><br><span class="line"><span class="comment">#con: 数据库连接</span></span><br><span class="line"><span class="comment">#if_exists：操作方式（fail:若表存在，则不输出,replace：若表存在，覆盖原来表里的数据append：若表存在，将数据写到原表的后面）</span></span><br><span class="line"><span class="comment">#index:是否将df的index单独写到一列中(False,True)</span></span><br><span class="line"><span class="comment">#index_label:指定列作为df的index输出，此时index为True</span></span><br><span class="line"><span class="comment">#dtype: 指定列的输出到数据库中的数据类型。字典形式储存：&#123;column_name: sql_dtype&#125;。常见的数据类型有sqlalchemy.types.INTEGER(), sqlalchemy.types.NVARCHAR(),sqlalchemy.Datetime()等，具体数据类型可以参考http://docs.sqlalchemy.org/en/latest/core/type_basics.html#sql-standard-and-multiple-vendor-types</span></span><br><span class="line">engine.dispose() <span class="comment">#关闭连接</span></span><br></pre></td></tr></table></figure>

<h3 id="6-5"><a href="#6-5" class="headerlink" title="6.5"></a>6.5</h3><h2 id="第-7-章-数据清洗与准备"><a href="#第-7-章-数据清洗与准备" class="headerlink" title="第 7 章 数据清洗与准备"></a>第 7 章 数据清洗与准备</h2><h3 id="7-1-处理缺失值"><a href="#7-1-处理缺失值" class="headerlink" title="7.1 处理缺失值"></a>7.1 处理缺失值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.a.isnull() <span class="comment">#使用isnull 过滤缺失值</span></span><br></pre></td></tr></table></figure>

<p>表7-1：NA处理方法</p>
<table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">dropna</td>
<td align="left">根据每个标签的值是否是缺失数据来筛选轴标签，并根据允许丢失的数据量来确当阈值</td>
</tr>
<tr>
<td align="left">fillna</td>
<td align="left">用某些值填充缺失的数据或使用插值方法（如’ffill’或’bfill’）</td>
</tr>
<tr>
<td align="left">isnull</td>
<td align="left">返回表明哪些是缺失值的布尔值</td>
</tr>
<tr>
<td align="left">notnull</td>
<td align="left">isnull的反函数</td>
</tr>
</tbody></table>
<h4 id="7-1-1-过滤缺失值"><a href="#7-1-1-过滤缺失值" class="headerlink" title="7.1.1 过滤缺失值"></a>7.1.1 过滤缺失值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.dropna() <span class="comment">#默认删除包含缺失值的行 使用how='all'参数删除所有值均为NA的行，使用axis=1删除列，thresh参数可以设定允许缺失值的阈值</span></span><br></pre></td></tr></table></figure>

<h4 id="7-1-2-补全缺失值"><a href="#7-1-2-补全缺失值" class="headerlink" title="7.1.2 补全缺失值"></a>7.1.2 补全缺失值</h4><p>表7-2：fillna函数参数</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">value</td>
<td align="left">标量值或字典型对象用于填充缺失值</td>
</tr>
<tr>
<td align="left">method</td>
<td align="left">插值方法，如果没有其它参数，默认是’ffill’</td>
</tr>
<tr>
<td align="left">axis</td>
<td align="left">需要填充的轴，默认axis=0</td>
</tr>
<tr>
<td align="left">inplace</td>
<td align="left">修改被调用的对象，而不是生成一个对象</td>
</tr>
<tr>
<td align="left">limit</td>
<td align="left">用于前向或者后向填充时最大的填充范围</td>
</tr>
</tbody></table>
<h3 id="7-2-数据转换"><a href="#7-2-数据转换" class="headerlink" title="7.2 数据转换"></a>7.2 数据转换</h3><h4 id="7-2-1-删除重复值"><a href="#7-2-1-删除重复值" class="headerlink" title="7.2.1 删除重复值"></a>7.2.1 删除重复值</h4><h4 id="7-2-2-使用函数或映射进行数据转换"><a href="#7-2-2-使用函数或映射进行数据转换" class="headerlink" title="7.2.2 使用函数或映射进行数据转换"></a>7.2.2 使用函数或映射进行数据转换</h4><h2 id="第-8-章-数据规整：连接、联合与重塑"><a href="#第-8-章-数据规整：连接、联合与重塑" class="headerlink" title="第 8 章 数据规整：连接、联合与重塑"></a>第 8 章 数据规整：连接、联合与重塑</h2><h3 id="8-1"><a href="#8-1" class="headerlink" title="8.1"></a>8.1</h3><h4 id="8-1-1"><a href="#8-1-1" class="headerlink" title="8.1.1"></a>8.1.1</h4><h4 id="8-1-2-按层级进行汇总统计"><a href="#8-1-2-按层级进行汇总统计" class="headerlink" title="8.1.2 按层级进行汇总统计"></a>8.1.2 按层级进行汇总统计</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.sum(level=<span class="number">0</span>) <span class="comment">#使用层级进行汇总</span></span><br><span class="line">df.sum(level=<span class="string">'索引名'</span>,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="8-1-3-使用-DataFrame-的列进行索引"><a href="#8-1-3-使用-DataFrame-的列进行索引" class="headerlink" title="8.1.3 使用 DataFrame 的列进行索引"></a>8.1.3 使用 DataFrame 的列进行索引</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.set_index(<span class="string">'A'</span>) <span class="comment">#使用A列作为索引</span></span><br><span class="line">df.set_index([<span class="string">'A'</span>,<span class="string">'c'</span>]) <span class="comment">#使用A,C列进行分层索引</span></span><br><span class="line"><span class="comment">#使用drop=False参数，可以使作为索引的列保留在DataFrame中</span></span><br><span class="line"><span class="comment">#reset_index是set_index的反函数</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-联合与合并数据"><a href="#8-2-联合与合并数据" class="headerlink" title="8.2 联合与合并数据"></a>8.2 联合与合并数据</h3><h4 id="8-2-1-数据库风格的-DataFrame-连接"><a href="#8-2-1-数据库风格的-DataFrame-连接" class="headerlink" title="8.2.1 数据库风格的 DataFrame 连接"></a>8.2.1 数据库风格的 DataFrame 连接</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(df1,df2,on=<span class="string">'key'</span>) <span class="comment">#可以分别指定列名left_on='lkey',right_on='rkey' 可使用参数how=</span></span><br></pre></td></tr></table></figure>

<p>表8-1：how 参数的不同连接类型</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="left">行为</th>
</tr>
</thead>
<tbody><tr>
<td align="center">‘inner’</td>
<td align="left">只对两张表都有的键的交集进行联合</td>
</tr>
<tr>
<td align="center">‘left’</td>
<td align="left">对所有左边的键都进行联合</td>
</tr>
<tr>
<td align="center">‘right’</td>
<td align="left">对所有右表的键都进行联合</td>
</tr>
<tr>
<td align="center">‘outer’</td>
<td align="left">对两张表都有的键的并集进行联合</td>
</tr>
</tbody></table>
<p>表8-2：merge函数参数</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">left</td>
<td align="left">合并时操作中左边的DataFrame</td>
</tr>
<tr>
<td align="left">right</td>
<td align="left">合并时操作中右边的DataFrame</td>
</tr>
<tr>
<td align="left">how</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">on</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">left_on</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">right_on</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">sort</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">suffixes</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">copy</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">indicator</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="8-2-2-根据索引合并"><a href="#8-2-2-根据索引合并" class="headerlink" title="8.2.2 根据索引合并"></a>8.2.2 根据索引合并</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(df1,df2,on=<span class="string">'key'</span>，right_index=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#可以分别指定列名left_on='lkey',right_on='rkey' 可使用参数how=</span></span><br><span class="line"><span class="comment">#可以传递left_index=True或tight_index=True(或者都传)来表示索引需要用来作为合并的键</span></span><br></pre></td></tr></table></figure>

<h4 id="8-2-3"><a href="#8-2-3" class="headerlink" title="8.2.3"></a>8.2.3</h4><h4 id="8-2-4"><a href="#8-2-4" class="headerlink" title="8.2.4"></a>8.2.4</h4><h2 id="第-9-章-绘图与可视化"><a href="#第-9-章-绘图与可视化" class="headerlink" title="第 9 章 绘图与可视化"></a>第 9 章 绘图与可视化</h2><h3 id="9-1-简明-matplotlib-API-入门"><a href="#9-1-简明-matplotlib-API-入门" class="headerlink" title="9.1 简明 matplotlib API 入门"></a>9.1 简明 matplotlib API 入门</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline <span class="comment">#用于在juputer notebook中显示图形</span></span><br></pre></td></tr></table></figure>

<h4 id="9-1-1-图片与子图"><a href="#9-1-1-图片与子图" class="headerlink" title="9.1.1 图片与子图"></a>9.1.1 图片与子图</h4><h4 id="9-1-2"><a href="#9-1-2" class="headerlink" title="9.1.2"></a>9.1.2</h4><h4 id="9-1-3"><a href="#9-1-3" class="headerlink" title="9.1.3"></a>9.1.3</h4><h4 id="9-1-4"><a href="#9-1-4" class="headerlink" title="9.1.4"></a>9.1.4</h4><h4 id="9-1-5-将图片保存到文件"><a href="#9-1-5-将图片保存到文件" class="headerlink" title="9.1.5 将图片保存到文件"></a>9.1.5 将图片保存到文件</h4><p>表9-2：figure.savefig选项</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fname</td>
<td align="left">包含文件路径或Python文件型对象的字符串。图片格式是从文件的扩展名中推断出来的（例如PDF格式的.pdf或PNG格式的.png格式）</td>
</tr>
<tr>
<td align="left">dpi</td>
<td align="left">每英寸点数的分辨率；默认为100，但可以配置</td>
</tr>
<tr>
<td align="left">faceclor,edgecolor</td>
<td align="left">子图之外的图形背景的颜色；默认情况下是’w’（白色）</td>
</tr>
<tr>
<td align="left">format</td>
<td align="left">文件格式(‘png’,’pdf’,’svg’,’ps’,’eps’……)</td>
</tr>
<tr>
<td align="left">bbox_inches</td>
<td align="left">要保存的图片范围；如果传递’tight’，将会去除掉图片周围空白的部分</td>
</tr>
</tbody></table>
<h4 id="9-1-6"><a href="#9-1-6" class="headerlink" title="9.1.6"></a>9.1.6</h4><h3 id="9-2-使用-pandas-和-seaborn-绘图"><a href="#9-2-使用-pandas-和-seaborn-绘图" class="headerlink" title="9.2 使用 pandas 和 seaborn 绘图"></a>9.2 使用 pandas 和 seaborn 绘图</h3>]]></content>
  </entry>
  <entry>
    <title>基于ProXmoX VE的虚拟化家庭服务器（篇五）—利用linux虚拟机编译lean源码openwrt</title>
    <url>/%E7%BC%96%E8%AF%91openwrt/</url>
    <content><![CDATA[<p>上篇讲了如何使用模板创建一个低资源占用高效的linux虚拟机<br>这篇我们讲一下如何利用这个虚拟机进行官方原版openwrt的编译，结合前段时间到手的新路由3，做一个简单的，支持802.11r的ap</p><a id="more"></a>
<h2 id="创建非root用户"><a href="#创建非root用户" class="headerlink" title="创建非root用户"></a>创建非root用户</h2><p>由于openwrt不能使用root用户git和编译，首要任务是创建一个非root用户，用来进行git和编译<br>首先，我们进入控制台打开root远程登录（确保更好的使用体验）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/ssh/sshd_config  </span><br><span class="line">找到下面相关配置：</span><br><span class="line"><span class="comment"># Authentication:  </span></span><br><span class="line"><span class="comment">#LoginGraceTime 120  </span></span><br><span class="line"><span class="comment">#PermitRootLogin prohibit-password  </span></span><br><span class="line"><span class="comment">#StrictModes yes  </span></span><br><span class="line">更改为：</span><br><span class="line"><span class="comment"># Authentication:  </span></span><br><span class="line"><span class="comment">#LoginGraceTime 120 </span></span><br><span class="line">PermitRootLogin yes  </span><br><span class="line"><span class="comment">#StrictModes yes</span></span><br></pre></td></tr></table></figure>

<p>保存退出<br>重启ubuntu</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p>然后就可以使用shell工具远程登录ubuntu虚拟机了<br>怎么登录我就不细说了，win下用putty或者xshel，我是mac，直接用终端登录<br>查看一下时间</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>

<p>发现时间不对，是由于时区的缘故，我们使用以下命令把时区设置到上海</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure>

<p>重新查看一下时间，已经正确<br>把源地址更换到国内</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nano /etc/apt/sources.list</span><br><span class="line"><span class="comment">#把</span></span><br><span class="line">deb http://archive.ubuntu.com/ubuntu cosmic main restricted universe multiverse</span><br><span class="line">deb http://archive.ubuntu.com/ubuntu cosmic-updates main restricted universe multiverse</span><br><span class="line">deb http://archive.ubuntu.com/ubuntu cosmic-security main restricted universe multiverse</span><br><span class="line"><span class="comment">#更换为</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu cosmic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu cosmic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu cosmic-security main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>更新一下系统</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</span><br></pre></td></tr></table></figure>

<p>创建用户</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adduser x <span class="comment">#创建一个叫做x的用户,会要求你输入密码，然后填一些资料，资料可以直接会车跳过</span></span><br></pre></td></tr></table></figure>

<p>赋予新用户root权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nano /etc/sudoers <span class="comment">#打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在  root    ALL=(ALL:ALL) ALL 下面添加</span></span><br><span class="line">x    ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>

<p>保存退出，然后重启ubuntu,使用新用户登录</p>
<h2 id="编译openwrt"><a href="#编译openwrt" class="headerlink" title="编译openwrt"></a>编译openwrt</h2><p>上回我们说编译原版openwrt，考虑了一下，还是教大家用lean的源码进行编译，因为功能更多更全，官方原版的只要换git地址就能一样编译。<br>首先我们使用shell工具登录ubuntu,推荐使用xsell和putty。<br>首先我们确保自己使用新建的用户登录，然后回到home目录下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint</span><br><span class="line"><span class="comment">#安装依赖</span></span><br><span class="line"><span class="built_in">cd</span> <span class="comment">#回到home目录</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/coolsnowwolf/lede" target="_blank" rel="noopener">Lean源码地址</a><br>下载git包（可能速度会比较慢，建议出国）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/coolsnowwolf/lede.git <span class="comment">#如果要编译官方openwrt 地址换成 https://www.github.com/openwrt/openwrt</span></span><br></pre></td></tr></table></figure>

<p>下载完成后会在</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/home/x/lede</span><br></pre></td></tr></table></figure>

<p>目录下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/x/lede</span><br></pre></td></tr></table></figure>

<p>源码插件(脚本等)更新并安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./scripts/feeds update -a </span><br><span class="line">./scripts/feeds install -a</span><br></pre></td></tr></table></figure>

<p>输入<code>make menuconfig</code>进行配置编辑<br>我是新路由3<br>配置按下图设置，其他软件包在Luci→Applications中设置<br><img src="//clegea.win/编译openwrt/Snipaste_2019-05-15_08-33-13.png" alt="配置"><br>插件的一些说明</p>
<blockquote>
<p>LuCI    Applications    luci-app-accesscontrol    访问时间控制<br>LuCI    Applications    luci-app-adblock    ADB广告过滤<br>LuCI    Applications    luci-app-adbyby-plus    广告屏蔽大师Plus +<br>LuCI    Applications    luci-app-advanced-reboot    高级重启<br>LuCI    Applications    luci-app-ahcp    支持AHCPd<br>LuCI    Applications    luci-app-aliddns    阿里DDNS客户端<br>LuCI    Applications    luci-app-amule    aMule是一个跨平台的ED2K/KAD客户端  P2P电驴下载<br>LuCI    Applications    luci-app-aria2    Aria2下载<br>LuCI    Applications    luci-app-arpbind    IP/MAC绑定<br>LuCI    Applications    luci-app-asterisk    支持Asterisk电话服务器<br>LuCI    Applications    luci-app-attendedsysupgrade    固件更新升级相关<br>LuCI    Applications    luci-app-autoreboot    支持计划重启<br>LuCI    Applications    luci-app-bcp38    BCP38网络入口过滤(不确定)<br>LuCI    Applications    luci-app-bird4    Bird4服务(未知)<br>LuCI    Applications    luci-app-bird6    Bird6服务(未知)<br>LuCI    Applications    luci-app-bmx6    BMX6路由协议<br>LuCI    Applications    luci-app-bmx7    BMX7路由协议<br>LuCI    Applications    luci-app-cjdns    加密IPV6网络相关<br>LuCI    Applications    luci-app-caldav    联系人<br>LuCI    Applications    luci-app-clamav    ClamAV杀毒软件<br>LuCI    Applications    luci-app-commands    Shell命令模块<br>LuCI    Applications    luci-app-cshark    CloudShark捕获工具<br>LuCI    Applications    luci-app-ddns    动态域名 DNS<br>LuCI    Applications    luci-app-diag-core    core诊断工具<br>LuCI    Applications    luci-app-dnscrypt-proxy    DNSCrypt解决DNS污染<br>LuCI    Applications    luci-app-dnsforwarder    DNSForwarder防DNS污染<br>LuCI    Applications    luci-app-dnspod    DNSPod<br>LuCI    Applications    luci-app-dump1090    民航无线频率(不确定)<br>LuCI    Applications    luci-app-dynapoint    DynaPoint(未知)<br>LuCI    Applications    luci-app-e2guardian    Web内容过滤器<br>LuCI    Applications    luci-app-filetransfer    文件传输<br>LuCI    Applications    luci-app-firewall    添加防火墙<br>LuCI    Applications    luci-app-freifunk-diagnostics    freifunk组件 诊断(未知)<br>LuCI    Applications    luci-app-freifunk-policyrouting    freifunk组件 策略路由(未知)<br>LuCI    Applications    luci-app-freifunk-widgets    freifunk组件 Widgets(未知)<br>LuCI    Applications    luci-app-frpc    内网穿透 Frp<br>LuCI    Applications    luci-app-fwknopd    Firewall Knock Operator服务器<br>LuCI    Applications    luci-app-guest-wifi    WiFi访客网络<br>LuCI    Applications    luci-app-hd-idle    硬盘休眠<br>LuCI    Applications    luci-app-hnet    Homenet Status家庭网络控制协议<br>LuCI    Applications    luci-app-ipsec-vpnd    VPN服务器 IPSec<br>LuCI    Applications    luci-app-lxc    LXC容器管理<br>LuCI    Applications    luci-app-meshwizard    网络设置向导<br>LuCI    Applications    luci-app-minidlna    完全兼容DLNA / UPnP-AV客户端的服务器软件<br>LuCI    Applications    luci-app-mjpg-streamer    兼容Linux-UVC的摄像头程序<br>LuCI    Applications    luci-app-mwan3    MWAN负载均衡<br>LuCI    Applications    luci-app-mwan3helper    MWAN3分流助手<br>LuCI    Applications    luci-app-n2n_v2    N2N 内网穿透 N2N v2 VPN服务<br>LuCI    Applications    luci-app-nlbwmon    网络带宽监视器<br>LuCI    Applications    luci-app-noddos    NodDOS Clients 阻止DDoS攻击<br>LuCI    Applications    luci-app-ntpc    NTP时间同步服务器<br>LuCI    Applications    luci-app-ocserv    OpenConnect VPN服务<br>LuCI    Applications    luci-app-olsr    OLSR配置和状态模块<br>LuCI    Applications    luci-app-olsr-services    OLSR服务器<br>LuCI    Applications    luci-app-olsr-viz    OLSR可视化<br>LuCI    Applications    luci-app-openvpn    OpenVPN客户端<br>LuCI    Applications    luci-app-openvpn-server    易于使用的 OpenVPN 服务器 Web-UI<br>LuCI    Applications    luci-app-p910nd    打印服务器模块<br>LuCI    Applications    luci-app-pagekitec    Pagekite 内网穿透客户端<br>LuCI    Applications    luci-app-polipo    Polipo 是一个小型且快速的网页缓存代理。<br>LuCI    Applications    luci-app-pppoe-relay    PPPoE NAT穿透 点对点协议（PPP）<br>LuCI    Applications    luci-app-pptp-server    VPN服务器 PPTP<br>LuCI    Applications    luci-app-privoxy    Privoxy网络代理（带过滤无缓存）<br>LuCI    Applications    luci-app-qos    流量服务质量(QoS)流控<br>LuCI    Applications    luci-app-radicale    CalDAV/CardDAV同步工具<br>LuCI    Applications    luci-app-ramfree    释放内存<br>LuCI    Applications    luci-app-rp-pppoe-server    Roaring Penguin PPPoE Server 服务器<br>LuCI    Applications    luci-app-samba    网络共享(samba)<br>LuCI    Applications    luci-app-samba4    网络共享(samba4)<br>LuCI    Applications    luci-app-sfe    Turbo ACC网络加速(开启Fast Path转发加速)<br>LuCI    Applications    luci-app-shadowsocks-libev    SS-libev服务端<br>LuCI    Applications    luci-app-shairplay    支持AirPlay功能<br>LuCI    Applications    luci-app-siitwizard    SIIT配置向导  SIIT-Wizzard<br>LuCI    Applications    luci-app-simple-adblock    简单的广告拦截<br>LuCI    Applications    luci-app-splash    Client-Splash是无线MESH网络的一个热点认证系统<br>LuCI    Applications    luci-app-sqm    流量智能队列管理(QOS)<br>LuCI    Applications    luci-app-squid    Squid代理服务器<br>LuCI    Applications    luci-app-ssr-plus    出国<br>        luci-app-ssr-plus    Include Shadowsocks New Versiong    新SS代理<br>        Include V2ray    V2Ray透明代理<br>        Include Kcptun    Kcptun代理<br>        Include ShadowsocksR Server    出国<br>        Include ShadowsocksR Socks and Tunnel    SSR代理<br>LuCI    Applications    luci-app-ssr-pro    出国<br>LuCI    Applications    luci-app-ssrserver-python    ShadowsocksR Python服务器<br>LuCI    Applications    luci-app-statistics    流量监控工具<br>LuCI    Applications    luci-app-syncdial    多拨虚拟WAN(原macvlan)<br>LuCI    Applications    luci-app-tinyproxy    Tinyproxy是 HTTP(S)代理服务器<br>LuCI    Applications    luci-app-transmission    BT下载工具<br>LuCI    Applications    luci-app-travelmate    旅行路由器<br>LuCI    Applications    luci-app-ttyd    网页终端命令行<br>LuCI    Applications    luci-app-udpxy    udpxy做组播服务器<br>LuCI    Applications    luci-app-uhttpd    uHTTPd Web服务器<br>LuCI    Applications    luci-app-unbound    Unbound DNS解析器<br>LuCI    Applications    luci-app-upnp    通用即插即用UPnP(端口自动转发)<br>LuCI    Applications    luci-app-usb-printer    USB 打印服务器<br>LuCI    Applications    luci-app-v2ray-pro    V2Ray透明代理<br>LuCI    Applications    luci-app-vlmcsd    KMS服务器（激活工具）<br>LuCI    Applications    luci-app-vnstat    vnStat网络监控（图表）<br>LuCI    Applications    luci-app-vpnbypass    VPN BypassWebUI  绕过VPN设置<br>LuCI    Applications    luci-app-vsftpd    FTP服务器<br>LuCI    Applications    luci-app-watchcat    断网检测功能与定时重启<br>LuCI    Applications    luci-app-webadmin    Web管理<br>LuCI    Applications    luci-app-wifischedule    WiFi 计划<br>LuCI    Applications    luci-app-wireguard    VPN服务器 WireGuard状态<br>LuCI    Applications    luci-app-wireless-regdb    WiFi无线<br>LuCI    Applications    luci-app-wol    WOL网络唤醒<br>LuCI    Applications    luci-app-wrtbwmon    实时流量监测<br>LuCI    Applications    luci-app-xlnetacc    迅雷快鸟<br>LuCI    Applications    luci-app-zerotier    内网穿透 ZeroTier</p>
</blockquote>
<p>配置完成后按几次ESC退出  最后输入Y确认保存配置<br>然后输入<br><code>make  download</code><br>进行插件包的预下载，时间会比较长，建议出国<br>下载完成后输入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make -j1 V=s <span class="comment">#-j1 后面是线程数。第一次编译推荐用单线程</span></span><br></pre></td></tr></table></figure>

<p>然后等待编译完成即可<br>编译完成后的固件会在<code>/home/x/lede/bin/targets</code>下的一个文件夹里，可使用winscp等工具下载下来</p>
]]></content>
      <tags>
        <tag>proxmox ve</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ProXmoX VE的虚拟化家庭服务器（篇四）—利用模板创建linux虚拟机</title>
    <url>/%E5%88%9B%E5%BB%BAlinux%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>前几篇我们讲了这么如何安装pve以及软路由等虚拟机，今天我们来讲一下如何使用模板来创建一个linux虚拟机。</p><a id="more"></a>
<h2 id="1-下载linux模板"><a href="#1-下载linux模板" class="headerlink" title="1.下载linux模板"></a>1.下载linux模板</h2><p>我们找到local存储或者我们上次添加的OS目录<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-08_21-41-39.png" alt="Snipaste_2019-04-08_21-41-39"></p>
<p>点开后他应该会包含有容器模板选项，如下图<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-08_21-44-23.png" alt="Snipaste_2019-04-08_21-44-23"><br>我们选择内容<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-08_21-57-07.png" alt><br>点击模板<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-08_21-58-10.png" alt="点击模版"><br>这里我们选择ubuntu-18.10<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_10-13-42.png" alt="ubuntu-18.10"><br>点击下载<br>由于下载服务器在国外，出国可以获得更好的下载速度（人不出国网出国）<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_10-14-07.png" alt="下载中"><br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_10-50-13.png" alt="下载完成"><br>这时候可以建linux虚拟机了</p>
<h2 id="2-创建虚拟机"><a href="#2-创建虚拟机" class="headerlink" title="2.创建虚拟机"></a>2.创建虚拟机</h2><p>点击创建CT<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_10-52-18.png" alt="创建CT"><br>设置主机名和root密码,注意去掉无特权容器的勾（如果要使用nfs的话）然后下一步<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_11-20-23.png" alt="设置主机名和密码"><br>选择模板，下一步<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_10-54-31.png" alt="选择模板"><br>设置磁盘大小，下一步<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_10-55-47.png" alt="设置磁盘大小"><br>设置cpu数量（其实就是使用的cpu资源比例）<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_10-56-34.png" alt="设置cpu数量"><br>设置内存大小，我设置到2g<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_10-57-58.png" alt="设置内存大小"><br>设置网络，注意桥接的接口，注意ip，默认静态，需要手动设置，或者使用dhcp获取<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_10-59-13.png" alt="设置网络"><br>设置dns，建议在主机设置dns后使用默认设置<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_11-00-45.png" alt="设置dns"><br>确认配置，完成<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_11-03-19.png" alt="确认配置"><br>显示ok表示创建成功<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_11-04-38.png" alt="确认配置"><br>如果要使用nfs挂载到这里打开，否则死活挂载不了<br><img src="//clegea.win/创建linux虚拟机/Snipaste_2019-04-18_11-25-13.png" alt="打开nfs"><br>然后就可以启动了<br>由于使用的是半虚拟化，加载的是proxmox宿主机的内核，启动速度超快，占用资源也非常小，<br>下篇我们讲一下如何使用ubuntu虚拟机编译原版openwrt固件</p>
]]></content>
      <tags>
        <tag>proxmox ve</tag>
      </tags>
  </entry>
  <entry>
    <title>软件与工具推荐</title>
    <url>/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h3 id="预览软件：QuickLook"><a href="#预览软件：QuickLook" class="headerlink" title="预览软件：QuickLook"></a>预览软件：QuickLook</h3><p>Windows快速查看工具。按空格快速预览。</p><h3 id="截图：Snipaste"><a href="#截图：Snipaste" class="headerlink" title="截图：Snipaste"></a>截图：Snipaste</h3><p>按F1开始剪切，然后按F3将其粘贴为浮动窗口，浮动窗口还支持文本。除了贴图功能外，Snipaste 作为截图工具也非常强大，完全可以满足日常截图需求。</p><a id="more"></a>

<h3 id="解压：Bandizip"><a href="#解压：Bandizip" class="headerlink" title="解压：Bandizip"></a>解压：Bandizip</h3><p>好多人推荐这个，亲自试用了下，果然比7z要好用些。果断更换推荐。这个还支持解压前预览。</p>
<h3 id="本地视频播放：PotPlayer"><a href="#本地视频播放：PotPlayer" class="headerlink" title="本地视频播放：PotPlayer"></a>本地视频播放：PotPlayer</h3><p>功能强大的播放器，十个推荐，九个有它。安装时完成时，推荐下载编码器。</p>
<h3 id="看图软件：Honeyview"><a href="#看图软件：Honeyview" class="headerlink" title="看图软件：Honeyview"></a>看图软件：Honeyview</h3><p>这软件和bandizip是一家的。软件界面挺清爽的。打开图片的速度好快。还有就是不用解压就能看压缩包图片。看漫画会很方便。</p>
<h3 id="IOS设备管理：iMazing"><a href="#IOS设备管理：iMazing" class="headerlink" title="IOS设备管理：iMazing"></a>IOS设备管理：iMazing</h3><p>传输和保存音乐、消息、文件和数据。安全备份任何 iPhone、iPad 或 iPod touch。iMazing 功能强大、易于使用，称得上是 Mac 和 PC 上最好的 iOS 设备管理器。最后这句说的没错。</p>
<h3 id="文件搜索-everything"><a href="#文件搜索-everything" class="headerlink" title="文件搜索 everything"></a>文件搜索 everything</h3><p>Everything 是速度最快的文件名搜索工具</p>
<h3 id="文件搜索-Listary"><a href="#文件搜索-Listary" class="headerlink" title="文件搜索 Listary"></a>文件搜索 Listary</h3><p>可是比everything更强大，有很多插件，缺点是搜索界面较小，没有everything全面</p>
<h3 id="字幕调整-Aegisub"><a href="#字幕调整-Aegisub" class="headerlink" title="字幕调整 Aegisub"></a>字幕调整 Aegisub</h3><h3 id="镜像刻录-rufus"><a href="#镜像刻录-rufus" class="headerlink" title="镜像刻录 rufus"></a>镜像刻录 rufus</h3><h3 id="公众号运营工具-壹伴"><a href="#公众号运营工具-壹伴" class="headerlink" title="公众号运营工具 壹伴"></a>公众号运营工具 壹伴</h3><p>主要有两点最吸引我的地方：融合进公众号后台，不需要跳转网页；强大的数据分析管理功能；它不需要像其他编辑器那样需要完成编辑之后再同步或者复制到微信公众号后台，能够让微信公众号编辑更加便捷高效。此外，强大的数据分析管理功能能够让30多项数据清晰可见，对自己的运营情况更加了如指掌。此外，壹伴还有连续格式刷、导入word、插入代码、图片编辑美化等便捷工具，大大提高公众号编辑效率。</p>
<h3 id="文件归类软件-DropIt"><a href="#文件归类软件-DropIt" class="headerlink" title="文件归类软件 DropIt"></a>文件归类软件 DropIt</h3><h3 id="文字识别-天若OCR"><a href="#文字识别-天若OCR" class="headerlink" title="文字识别 天若OCR"></a>文字识别 天若OCR</h3><h3 id="word排版插件-小恐龙公文排版助手"><a href="#word排版插件-小恐龙公文排版助手" class="headerlink" title="word排版插件 小恐龙公文排版助手"></a>word排版插件 小恐龙公文排版助手</h3>]]></content>
  </entry>
  <entry>
    <title>利用hexo+github+coding（腾讯云开发平台）架设个人博客</title>
    <url>/%E5%88%A9%E7%94%A8hexo+github+coding%E6%9E%B6%E8%AE%BE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="一、Hexo介绍"><a href="#一、Hexo介绍" class="headerlink" title="一、Hexo介绍"></a>一、Hexo介绍</h2><p>初次了解到hexo是在<strong>骆昊</strong>大神的python教程《<a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python - 100天从新手到大师</a>》,然后就去百度以及官网上看了下资料，发现这是一个非常轻量、简洁、部署方式非常“程序员”的一个个人博客。</p><a id="more"></a>
<ul>
<li>Hexo 的中文官网：<a href="http://hexo.io/zh-cn/" target="_blank" rel="noopener">http://hexo.io/zh-cn/</a></li>
<li>作者 Tommy Chen：<a href="https://zespia.tw/" target="_blank" rel="noopener">https://zespia.tw/</a></li>
</ul>
<h2 id="二、部署"><a href="#二、部署" class="headerlink" title="二、部署"></a>二、部署</h2><p>部署分以下几步走</p>
<ol>
<li>搭建node环境</li>
<li>搭建git环境</li>
<li>安装hexo以及GitHub、coding设置</li>
<li>个人域名设置</li>
</ol>
<blockquote>
<p>由于我是部署在CentOS 7 上的，所以一下内容均以CentOS 7 作为平台</p>
</blockquote>
<h3 id="2-1-搭建node环境"><a href="#2-1-搭建node环境" class="headerlink" title="2.1 搭建node环境"></a>2.1 搭建node环境</h3><p>CentOS下非常简单<br>只要输入以下命令就可以自动安装node以及npm（npm是node的包管理工具）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install nodejs</span><br><span class="line">yum install npm</span><br></pre></td></tr></table></figure>

<p>可以使用以下命令查看是否安装成功</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>npm加速</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h3 id="2-2-搭建git环境"><a href="#2-2-搭建git环境" class="headerlink" title="2.2 搭建git环境"></a>2.2 搭建git环境</h3><p>和node一样简单</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure>

<p>使用以下命令查看版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<h3 id="2-3-安装hexo以及GitHub、coding设置"><a href="#2-3-安装hexo以及GitHub、coding设置" class="headerlink" title="2.3 安装hexo以及GitHub、coding设置"></a>2.3 安装hexo以及GitHub、coding设置</h3><h4 id="2-3-1-安装hexo"><a href="#2-3-1-安装hexo" class="headerlink" title="2.3.1 安装hexo"></a>2.3.1 安装hexo</h4><p>首先CD到home目录下,</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br></pre></td></tr></table></figure>

<p>使用以下命令安装hexo（安装过程中会自动创建一个blog文件夹路径为/home/blog）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g </span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：生成文章的一些模板</li>
<li>source：用来存放你的文章</li>
<li>themes：主题</li>
<li>_config.yml: 博客的配置文件 </li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo g <span class="comment">#生成静态页面</span></span><br><span class="line">hexo server <span class="comment">#启动本地服务</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-创建github仓库"><a href="#2-3-2-创建github仓库" class="headerlink" title="2.3.2 创建github仓库"></a>2.3.2 创建github仓库</h4><p>首先注册一个GitHub账户<br>注册完成登录后，在github.com中看到一个<strong>new</strong>，新建仓库</p>
<p><img src="//clegea.win/利用hexo+github+coding架设个人博客/Snipaste_2019-07-29_13-57-38.png" alt></p>
<p>创建一个和你用户名相同的仓库，后面加.github.io,&lt;<strong>yourname.github.io</strong>&gt;这样在部署到GitHub page的时候等于网页在你的根目录,这里因为我已经创建过了，所以是红色叹号<br><img src="//clegea.win/利用hexo+github+coding架设个人博客/Snipaste_2019-07-29_13-58-26.png" alt></p>
<p>点击<strong>Create repository</strong>。</p>
<h4 id="2-3-3-创建coding仓库"><a href="#2-3-3-创建coding仓库" class="headerlink" title="2.3.3 创建coding仓库"></a>2.3.3 创建coding仓库</h4><p>创建coding仓库的时候有个小坑，就是coding个人仓库业务好像被腾讯收购了，现在进入coding个人仓库要从</p>
<p><strong>腾讯云开发者平台</strong>：<a href="https://dev.tencent.com/" target="_blank" rel="noopener">https://dev.tencent.com/</a> 进入</p>
<p>绑定邮箱时尽量使用和github相同的邮箱账户</p>
<p>从右上角的＋号-项目 新建仓库</p>
<p><img src="//clegea.win/利用hexo+github+coding架设个人博客/Snipaste_2019-07-29_14-06-32.png" alt></p>
<p>项目名称使用&lt;<strong>yourname.coding.me</strong>&gt;创建，同样是为了pages服务方便</p>
<p><img src="//clegea.win/利用hexo+github+coding架设个人博客/Snipaste_2019-07-29_14-07-36.png" alt></p>
<p>点击新建项目</p>
<h4 id="2-3-4-生成ssh-key-添加到github和coding"><a href="#2-3-4-生成ssh-key-添加到github和coding" class="headerlink" title="2.3.4 生成ssh key 添加到github和coding"></a>2.3.4 生成ssh key 添加到github和coding</h4><p>回到ContOS 7 中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">git config --global user.email <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure>

<p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。</p>
<p>可以用以下两条命令检查git的用户名和密码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>

<p>使用以下命令生成ssh key </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure>

<p>id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p>
<p><img src="//clegea.win/利用hexo+github+coding架设个人博客/Snipaste_2019-07-29_14-17-21.png" alt><br><img src="//clegea.win/利用hexo+github+coding架设个人博客/Snipaste_2019-07-29_14-17-41.png" alt><br>而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key<br>把你的id_rsa.pub里面的信息复制进去。</p>
<p>coding操作类似<br><img src="//clegea.win/利用hexo+github+coding架设个人博客/Snipaste_2019-07-29_14-18-35.png" alt></p>
<p>绑定完成后可以使用以下命令来分别测试是否可以正确连接</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">ssh -T git@git.dev.tencent.com</span><br></pre></td></tr></table></figure>

<p>安装git插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>如果测试无误，就可以使用以下命令来部署到github和coding上了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo clean <span class="comment">#做以下清理</span></span><br><span class="line">hexo g <span class="comment">#生成页面</span></span><br><span class="line">hexo d <span class="comment">#部署到git仓库</span></span><br><span class="line"><span class="comment">#hexo d --g #简化命令</span></span><br></pre></td></tr></table></figure>

<p>以上命令需要在blog目录下进行</p>
<h4 id="2-3-5-个人域名设置"><a href="#2-3-5-个人域名设置" class="headerlink" title="2.3.5 个人域名设置"></a>2.3.5 个人域名设置</h4><p>我这里使用dnspod域名解析做例子，dnspod搭配freenom免费域名非常好用</p>
<p>添加两个CNAME记录，记录值分别填两个git仓库的静态域名</p>
<p><img src="//clegea.win/利用hexo+github+coding架设个人博客/Snipaste_2019-07-29_16-45-28.png" alt></p>
<p>同时，在hexo的./blog/source目录下创建一个CNAME文件，内容为你的域名，比如我的就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clegea.cf</span><br></pre></td></tr></table></figure>

<p>填写完成后保存，重新部署一下，过一会应该就能使用你自己的个人域名访问了</p>
<h2 id="三、更换主题及一些优化设置"><a href="#三、更换主题及一些优化设置" class="headerlink" title="三、更换主题及一些优化设置"></a>三、更换主题及一些优化设置</h2><p>博客已经搭建完成，不过不是很好看，这时候我们就可以安装来进行一些美化。</p>
<p>官方主题库：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p>
<p>这里我推荐NexT主题，非常简洁，符合当下审美</p>
<p>NexT官方文档：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></p>
<p>我们直接git NexT的最新版本，使用以下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/blog <span class="comment">#确保在blog目录下</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>修改blog目录下的 _config.yml文件启用next</p>
<p>简书上有一篇非常详细的next主题的配置文件说明:<a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">Hexo的Next主题详细配置</a><br><strong>使首页使用缩略模式</strong><br>进入hexo博客项目的themes/next目录<br>用文本编辑器打开_config.yml文件<br>搜索”auto_excerpt”,找到如下部分：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Automatically Excerpt. Not recommand.</span></span><br><span class="line"><span class="comment">#Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>

<p>把enable改为对应的false改为true，然后hexo d -g<br><strong>使用本地图片</strong></p>
<ol>
<li>确认全局配置文件_config.yml 中有 post_asset_folder:true。</li>
<li>在hexo的目录下执行<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/7ym0n/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>打开搜索功能</strong></p>
<ol>
<li><p>安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局配置文件_config.yml，新增如下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>hexo主题配置文件（\themes\next_config.yml），修改local_search的enable为true：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line"><span class="attr">  trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line"><span class="attr">  top_n_per_article:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>利用proxmox ve 搭建家庭服务器</title>
    <url>/%E5%88%A9%E7%94%A8proxmox%E6%90%AD%E5%BB%BA%E5%AE%B6%E5%BA%AD%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="ProXmoX-VE-介绍"><a href="#ProXmoX-VE-介绍" class="headerlink" title="ProXmoX VE 介绍"></a>ProXmoX VE 介绍</h2><p>Proxmox VE是一款套开源的虚拟化管理软件，用户可通过网页的方式来管理服务器上使用 kvm 以及 lxc 技术运行的虚拟机。同时提供了一些先进功能的支持，如集群、HA等。<br>PVE虽然是开源，却是由一个商业公司在运营、更新以及维护。<br>基础安装完工</p><a id="more"></a>
<h2 id="ProXmoX-VE-安装"><a href="#ProXmoX-VE-安装" class="headerlink" title="ProXmoX VE 安装"></a>ProXmoX VE 安装</h2><h3 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h3><ol>
<li>16G以上U盘一个(非必须，这个U盘是用来安装PROXMOX的，也可以直接装硬盘上，GEN8比较特殊，使用U盘引导比较方便，所以我安装在U盘上)；4G以上U盘一个；</li>
<li>支持虚拟化技术的CPU；</li>
<li>如果要虚拟软路由，需要有2个网口以上，最好千兆。</li>
</ol>
<h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>首先去proxmox下载安装包，目前最新版本是5.2-1，推荐使用种子下载，速度会比较快，下载完成后务必使用使用工具进行SHA256校验，防止下载错误<br>然后使用软碟通或者rufus之类的工具把下载的ISO文件刻录进4G的U盘（本人使用GEN8的ILO4远程安装，有GEN8的朋友应该知道咋弄）。<br>接着把4GU盘和16GU盘插入电脑，BIOS中开启虚拟化支持（具体方法百度，BIOS太多，我就不放图了），一个网口接入路由，使用4GU盘引导启动很快就会进入安装界面。<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/1.png" alt="enter image description here"><br>此处选择第一项回车，稍微等待一会，进入下图界面<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/2.png" alt="enter image description here"><br>选择 I agree<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/3.png" alt="enter image description here"><br>这里选择你要安装的的硬盘或者U盘，选定后点击Next<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/4.png" alt="enter image description here"><br>这里一般会默认china，如果没有那就输入china，其他默认，点击Next<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/5.png" alt="enter image description here"><br>输入两遍管理密码并输入邮箱，点击Next<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/6.png" alt="enter image description here"><br>这里注意，查看一下是不是你局域网的网段，如果不是，很可能和路由之间网络不通，另外，Hostname这项的格式需为<em>.</em>，默认的是无法下一步的，我这里使用PVE.LEN，点击next，等待安装完成<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/7.png" alt="enter image description here"><br>出现如上界面时，说明安装已经完成，点击reboot，重启过程中拔掉U盘，然后设置为你安装的U盘或者硬盘启动，等待重启完成。<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/8.png" alt="enter image description here"><br>出现如上界面时说明安装完成了,用另外一台电脑在浏览器中输入上面的地址进行访问<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/9.png" alt="enter image description here"><br>language选择chinese就可以中文访问啦，用户名输入root，密码为刚才安装时候输的两遍管理密码</p>
<h2 id="ProXmoX-VE-初始配置"><a href="#ProXmoX-VE-初始配置" class="headerlink" title="ProXmoX VE 初始配置"></a>ProXmoX VE 初始配置</h2><p><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/10.png" alt="enter image description here"></p>
<p>由于proxmox一些功能是需要付费订阅的，虽然可以免费使用，但是每次登陆时候都会弹出如上让你订阅的通知，比较烦，我们这里通过技术手段把它屏蔽掉。<br>首先点击确定把它关掉，然后通过winscp打开以下文件 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js</span><br></pre></td></tr></table></figure>

<p><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/11.png" alt="enter image description here"><br>或者直接在web界面的shell中使用vi、nano等工具编辑找到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (data.status!==&apos;Active&apos;)</span><br></pre></td></tr></table></figure>

<p>替换为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (false)</span><br></pre></td></tr></table></figure>

<p>这条位置比较靠后，大约在800行，替换完成后保存文件，注销登陆，清理浏览器缓存，再次登陆，发现已经不再弹窗让你订阅啦。<br>接下来下来我们更新一下proxomx的软件，proxmox的底层毕竟是个debian系统，刚安装还是要更新一下的，在shell中输入aptupdate &amp;&amp; apt dist-upgrade，回车，发现报错无法更新，查看官方文档发现需要更改一些设置，在shell输入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rm -f /etc/apt/sources.list.d/pve-enterprise.list <span class="comment">#移除原更新原地址</span></span><br></pre></td></tr></table></figure>

<p>添加新的原地址</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://download.proxmox.com/debian/pve stretch pve-no-subscription"</span> &gt; /etc/apt/sources.list.d/pve-install-repo.list</span><br></pre></td></tr></table></figure>

<p>下载秘钥</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget http://download.proxmox.com/debian/proxmox-ve-release-5.x.gpg -O /etc/apt/trusted.gpg.d/proxmox-ve-release-5.x.gpg</span><br></pre></td></tr></table></figure>

<p>更新</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt update &amp;&amp; apt dist-upgrade</span><br></pre></td></tr></table></figure>

<p>等待更新完成，输入 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p>重启服务器</p>
<h2 id="ProXmoX-VE-磁盘映射"><a href="#ProXmoX-VE-磁盘映射" class="headerlink" title="ProXmoX VE 磁盘映射"></a>ProXmoX VE 磁盘映射</h2><p>如果你的proxmox是直接安装在硬盘上的，那已经可以正常使用了，如果你和我一样是安装在U盘的，因为U盘空间比较小，需要弄个硬盘用来安装虚拟机<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/12.png" alt="enter image description here"><br>在磁盘中看下哪个是你要挂载的硬盘，，我这里需要挂载的设备目录为/dev/sdb<br>在shell中输入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir /mnt/sdb</span><br></pre></td></tr></table></figure>

<p>创建sdb文件夹用来给磁盘挂载<br>输入fdisk /dev/sdb管理这个硬盘，给它分区<br>输入n新建分区<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/13.png" alt="enter image description here"><br>输入p建立主分区<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/14.png" alt="enter image description here"><br>输入1创建一个分区<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/15.png" alt="enter image description here"><br>这里是让输入这个分区的扇区起始位置，我们选择默认，直接回车<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/16.png" alt="enter image description here"><br>分区的扇区结束位置，默认，直接回车，到此就分区完成了，我们输入p查看一下<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/17.png" alt="enter image description here"><br>分区已经完成，目录为/dev/sdb1<br>输入w，保存并退出fdisk工具<br>输入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkfs -t ext4 /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>格式化一下<br>输入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mount /dev/sdb1 /mnt/sdb</span><br></pre></td></tr></table></figure>

<p>进行挂载<br>为了使proxmox可以开机自动挂载<br>我们输入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nano /etc/fstab</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">编辑一下这个文件，在最后追加</span><br><span class="line">```sh</span><br><span class="line">/dev/sdb1 /mnt/sdb ext4 defaults 0 0</span><br></pre></td></tr></table></figure>

<p>保存退出<br>这样就不用每次开机mount了<br>然后依次点击数据中心-存储-添加-目录<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/18.png" alt="enter image description here"><br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/19.png" alt="enter image description here"><br>ID随意，目录输入刚才挂载的目录，内容都选上，点添加，<br>最后点OS查看一下是否正常识别<br><img src="http://ddns.clegea.win:8000/wordpress/wp-content/uploads/2019/02/20.png" alt="enter image description here"></p>
]]></content>
      <tags>
        <tag>proxmox ve</tag>
      </tags>
  </entry>
  <entry>
    <title>蚂蚁</title>
    <url>/%E8%9A%82%E8%9A%81/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>也不记得具体时间了，大约是一个月前，屋子里飞来一只小虫子，老婆呼喊着我去打死，我跑去一看，这不是一只婚飞的蚁后么（婚飞：蚁后未交配时是有翅膀的，飞出巢穴和雄蚁交配，交配完成后便会飞到一处挖个洞生下第一窝蚂蚁），立马拿出一个试管，堵上一半水，把它抓了起来，然后就放在一个角落里不管他了</p><a id="more"></a>
<h2 id="7月26日"><a href="#7月26日" class="headerlink" title="7月26日"></a>7月26日</h2><p>今天拿出来一看，已经脱翅生了一堆卵了，看来是一只交配过的蚁后</p>
<p><img src="//clegea.win/蚂蚁/3.jpg" alt><br><img src="//clegea.win/蚂蚁/2.jpg" alt><br><img src="//clegea.win/蚂蚁/1.jpg" alt><br><img src="//clegea.win/蚂蚁/0.jpg" alt></p>
<h2 id="8月12日"><a href="#8月12日" class="headerlink" title="8月12日"></a>8月12日</h2><p>又是十多天过去了，一看，已经有两个超小的蚂蚁出生了,看小蚂蚁屁股的样子，应该是种举腹蚁<br><img src="//clegea.win/蚂蚁/4.jpg" alt></p>
]]></content>
  </entry>
</search>
