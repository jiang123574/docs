<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[引用自骆昊Python - 100天从新手到大师关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫《正则表达式30分钟入门教程》，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \w 匹配字母/数字/下划线 b\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \s 匹配空白字符（包括\r、\n、\t等） love\syou 可以匹配love you \d 匹配数字 \d\d 可以匹配01 / 23 / 99等 \b 匹配单词的边界 \bThe\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 $ 匹配字符串的结束 .exe$ 可以匹配.exe结尾的字符串 \W 匹配非字母/数字/下划线 b\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \S 匹配非空白字符 love\Syou 可以匹配love#you等但不能匹配love you \D 匹配非数字 \d\D 可以匹配9a / 3# / 0F等 \B 匹配非单词边界 \Bio\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符 * 匹配0次或多次 \w* + 匹配1次或多次 \w+ ? 匹配0次或1次 \w? {N} 匹配N次 \w{3} {M,} 匹配至少M次 \w{3,} {M,N} 匹配至少M次至多N次 \w{3,6} | 分支 foo|bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?&nbsp;&lt;name&gt;exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \b\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\bdanc)\w+\b 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.*ba.*?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 说明： 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则圆括号被视为正则表达式中的分组。 Python对正则表达式的支持Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 123456789101112131415161718192021222324252627import redef main(): # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字 pattern = re.compile(r'(?&lt;=\D)1[34578]\d&#123;9&#125;(?=\D)') sentence = ''' 重要的事情说8130123456789遍，我的手机号是13512346789这个靓号， 不是15600998765，也是110或119，王大锤的手机号才是15600998765。 ''' # 查找所有匹配并保存到一个列表中 mylist = re.findall(pattern, sentence) print(mylist) print('--------华丽的分隔线--------') # 通过迭代器取出匹配对象并获得匹配的内容 for temp in pattern.finditer(sentence): print(temp.group()) print('--------华丽的分隔线--------') # 通过search函数指定搜索位置找出所有匹配 m = pattern.search(sentence) while m: print(m.group()) m = pattern.search(sentence, m.end())if __name__ == '__main__': main()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas学习笔记]]></title>
    <url>%2Fpandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据库操作1234567891011engine=create_engine("mysql+pymysql://root:password@127.0.0.1:3306/&lt;sqldata&gt;?charset=utf8",pool_timeout=30) #连接数据库 pool_timeout：连接超时 sqldata:数据库名称pd.read_sql('select * from &lt;sqldata&gt;',engine,index_col='a') #读取数据库 index_col：索引列 &lt;sqldata&gt;:数据库表名con = engine.connect() #创建数据库指针pd.to_sql(name='sqldata', con=con, if_exists='append', index=False)#name:输出表名 #con: 数据库连接 #if_exists：操作方式（fail:若表存在，则不输出,replace：若表存在，覆盖原来表里的数据append：若表存在，将数据写到原表的后面）#index:是否将df的index单独写到一列中(False,True)#index_label:指定列作为df的index输出，此时index为True#dtype: 指定列的输出到数据库中的数据类型。字典形式储存：&#123;column_name: sql_dtype&#125;。常见的数据类型有sqlalchemy.types.INTEGER(), sqlalchemy.types.NVARCHAR(),sqlalchemy.Datetime()等，具体数据类型可以参考http://docs.sqlalchemy.org/en/latest/core/type_basics.html#sql-standard-and-multiple-vendor-typesengine.dispose() #关闭连接 excel操作 123456789101112131415pandas.read_excel（io，sheet_name = 0，header = 0，names = None，index_col = None，usecols = None，squeeze = False,dtype = None, ...）#io:文件路径#sheet_name:sheet_name=0,sheet_name=“Sheet1”,sheet_name=[0,1,'Sheet5']#header：指定作为列名的行,默认0，即取第一行的值为列名。数据为列名行以下的数据；若数据不含列名，则设定 header = None。#names：默认为None，要使用的列名列表，如不包含标题行，应显示传递header=None。#index_col：指定列为索引列，默认None列（0索引）用作DataFrame的行标签。#usecols：int或list，默认为None。##如果为None则解析所有列##如果为int则表示要解析的最后一列##如果为int列表则表示要解析的列号列表##如果字符串则表示以逗号分隔的Excel列字母和列范围列表（例如“A：E”或“A，C，E：F”）。范围包括双方。#squeeze：boolean，默认为False,如果解析的数据只包含一列，则返回一个Series。#skiprows：省略指定行数的数据,从第一行开始。#skipfooter：省略指定行数的数据，从尾部数的行开始。#dtype:字典类型&#123;'列名1':数据类型，‘列名’:数据类型&#125;，设定指定列的数据类型。 对于时间序列的一些操作 1234567import pandas as pdx=pd.DataFrame(&#123;'date':['2016-01-20','2016-01-30','2016-02-25','2016-03-05']&#125;,index=['a','c','b','a'])x['date']=x['date'].astype('datetime64') #转换数据类型x['date'].dt.week #计算第几周pd.Timestamp.now() #现在时间pd.Timedelta(days=4) #创建一个时间长度pd.Timestamp('2019-08-15') #创建一个时间 索引 123456789101112df['a'] #默认为列索引df.loc['a'] #行索引df.iloc[2] #行索引df.loc[:,'a'] #列索引df.loc[df.A=1,'a'] #布尔索引行后索引列df[df.a.isin(s)] #索引a列中含s数据的行df[~df.a.isin(s)] #索引a列中不含s数据的行df.reset_index() #还原索引df.columns=['a','b'] #重新命名列索引df.index=['a','b'] #重新命名行索引df.drop(['a']) #删除行，使用axis=1参数，删除列df.a.unique() #唯一值 多层索引 123456import pandas as pdarrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']]x=[1,2,3,4]y=pd.MultiIndex.from_arrays(arrays,names=['num','c']) #pd.MultiIndex.from_product([["A","B"],['x1','y1']],names=["class1","class2"]) #从笛卡尔积创建Multilndex对象pd.DataFrame(x,y).T 分组 12 DataFrame连接 123df1=pd.DataFrame(&#123;'款号':['818009'],'数量':[20]&#125;)df2=pd.DataFrame(&#123;'款号':['818009'],'大类':['xx'],'小类':['cc']&#125;)pd.merge(df2,df1,on='款号') 操作元素 1234a=lambda a: a.upper()df['x']=df['x'].map(a)df=df.applymap(a) #操作每个元素df=df.apply(a) #操作一行或者一列（使用参数 axis） 重复数据 12df.duplicated() #重复值的布尔数组df.drop_duplicates() #删除重复值]]></content>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Python进行数据分析]]></title>
    <url>%2F%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[第 1 章 准备工作1.1 本书内容1.1.1 什么类型的数据1.2 为何利用 Python 进行数据分析1.2.1 Python作为胶水1.2.2 解决“双语言”难题1.2.3 为何不使用 Python1.3 重要的 Python库第 2 章第 3 章第 4 章第 5 章5.15.1.15.1.25.1.3 索引对象表5-2：一些索引对象的方法和属性 方法 描述 append 将额外的索引对象粘贴到原索引后，产生一个新的索引 difference 计算两个索引的差集 intersection 计算两个索引的交集 union 计算两个索引的并集 isin 计算表示每一个值是否在传值容器中的布尔数组 delete 键位置i的元素删除，并产生新的索引 drop 根据传参删除指定索引值，并产生新的索引 insert 在位置i插入元素，并产生新的索引 is_monotonic 如果索引序列递增则返回True is_unique 如果索引序列唯一则返回True unique 计算索引的唯一值序列 第 6 章 数据载入、存储及文件格式6.1 文本格式数据的读写6.1.16.1.26.1.36.1.46.1.56.2 二进制格式6.2.1 使用 HDF5 格式12df.to_hdf('./x.h5','key')pd.read_hdf('./x.h5','key') 6.2.2 读取Microsoft Excel 文件excel操作 123456789101112131415pandas.read_excel（io，sheet_name = 0，header = 0，names = None，index_col = None，usecols = None，squeeze = False,dtype = None, ...）#io:文件路径#sheet_name:sheet_name=0,sheet_name=“Sheet1”,sheet_name=[0,1,'Sheet5']#header：指定作为列名的行,默认0，即取第一行的值为列名。数据为列名行以下的数据；若数据不含列名，则设定 header = None。#names：默认为None，要使用的列名列表，如不包含标题行，应显示传递header=None。#index_col：指定列为索引列，默认None列（0索引）用作DataFrame的行标签。#usecols：int或list，默认为None。##如果为None则解析所有列##如果为int则表示要解析的最后一列##如果为int列表则表示要解析的列号列表##如果字符串则表示以逗号分隔的Excel列字母和列范围列表（例如“A：E”或“A，C，E：F”）。范围包括双方。#squeeze：boolean，默认为False,如果解析的数据只包含一列，则返回一个Series。#skiprows：省略指定行数的数据,从第一行开始。#skipfooter：省略指定行数的数据，从尾部数的行开始。#dtype:字典类型&#123;'列名1':数据类型，‘列名’:数据类型&#125;，设定指定列的数据类型。 6.3 与Web API 交互6.4 与数据库交互数据库操作 1234567891011engine=create_engine("mysql+pymysql://root:password@127.0.0.1:3306/&lt;sqldata&gt;?charset=utf8",pool_timeout=30) #连接数据库 pool_timeout：连接超时 sqldata:数据库名称pd.read_sql('select * from &lt;sqldata&gt;',engine,index_col='a') #读取数据库 index_col：索引列 &lt;sqldata&gt;:数据库表名con = engine.connect() #创建数据库指针pd.to_sql(name='sqldata', con=con, if_exists='append', index=False)#name:输出表名#con: 数据库连接#if_exists：操作方式（fail:若表存在，则不输出,replace：若表存在，覆盖原来表里的数据append：若表存在，将数据写到原表的后面）#index:是否将df的index单独写到一列中(False,True)#index_label:指定列作为df的index输出，此时index为True#dtype: 指定列的输出到数据库中的数据类型。字典形式储存：&#123;column_name: sql_dtype&#125;。常见的数据类型有sqlalchemy.types.INTEGER(), sqlalchemy.types.NVARCHAR(),sqlalchemy.Datetime()等，具体数据类型可以参考http://docs.sqlalchemy.org/en/latest/core/type_basics.html#sql-standard-and-multiple-vendor-typesengine.dispose() #关闭连接 6.5第 7 章 数据清洗与准备7.1 处理缺失值1df.a.isnull() #使用isnull 过滤缺失值 表7-1：NA处理方法 函数名 描述 dropna 根据每个标签的值是否是缺失数据来筛选轴标签，并根据允许丢失的数据量来确当阈值 fillna 用某些值填充缺失的数据或使用插值方法（如’ffill’或’bfill’） isnull 返回表明哪些是缺失值的布尔值 notnull isnull的反函数 7.1.1 过滤缺失值1df.dropna() #默认删除包含缺失值的行 使用how='all'参数删除所有值均为NA的行，使用axis=1删除列，thresh参数可以设定允许缺失值的阈值 7.1.2 补全缺失值表7-2：fillna函数参数 参数 描述 value 标量值或字典型对象用于填充缺失值 method 插值方法，如果没有其它参数，默认是’ffill’ axis 需要填充的轴，默认axis=0 inplace 修改被调用的对象，而不是生成一个对象 limit 用于前向或者后向填充时最大的填充范围 7.2 数据转换7.2.1 删除重复值7.2.2 使用函数或映射进行数据转换第 8 章 数据规整：连接、联合与重塑8.18.1.18.1.2 按层级进行汇总统计12df.sum(level=0) #使用层级进行汇总df.sum(level='索引名',axis=1) 8.1.3 使用 DataFrame 的列进行索引1234df.set_index('A') #使用A列作为索引df.set_index(['A','c']) #使用A,C列进行分层索引#使用drop=False参数，可以使作为索引的列保留在DataFrame中#reset_index是set_index的反函数 8.2 联合与合并数据8.2.1 数据库风格的 DataFrame 连接1pd.merge(df1,df2,on='key') #可以分别指定列名left_on='lkey',right_on='rkey' 可使用参数how= 表8-1：how 参数的不同连接类型 选项 行为 ‘inner’ 只对两张表都有的键的交集进行联合 ‘left’ 对所有左边的键都进行联合 ‘right’ 对所有右表的键都进行联合 ‘outer’ 对两张表都有的键的并集进行联合 表8-2：merge函数参数 参数 描述 left 合并时操作中左边的DataFrame right 合并时操作中右边的DataFrame how on left_on right_on sort suffixes copy indicator 8.2.2 根据索引合并123pd.merge(df1,df2,on='key'，right_index=True)#可以分别指定列名left_on='lkey',right_on='rkey' 可使用参数how=#可以传递left_index=True或tight_index=True(或者都传)来表示索引需要用来作为合并的键 8.2.38.2.4第 9 章 绘图与可视化9.1 简明 matplotlib API 入门1%matplotlib inline #用于在juputer notebook中显示图形 9.1.1 图片与子图9.1.29.1.39.1.49.1.5 将图片保存到文件表9-2：figure.savefig选项 参数 描述 fname 包含文件路径或Python文件型对象的字符串。图片格式是从文件的扩展名中推断出来的（例如PDF格式的.pdf或PNG格式的.png格式） dpi 每英寸点数的分辨率；默认为100，但可以配置 faceclor,edgecolor 子图之外的图形背景的颜色；默认情况下是’w’（白色） format 文件格式(‘png’,’pdf’,’svg’,’ps’,’eps’……) bbox_inches 要保存的图片范围；如果传递’tight’，将会去除掉图片周围空白的部分 9.1.69.2 使用 pandas 和 seaborn 绘图]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于ProXmoX VE的虚拟化家庭服务器（篇五）—利用linux虚拟机编译lean源码openwrt]]></title>
    <url>%2F%E7%BC%96%E8%AF%91openwrt%2F</url>
    <content type="text"><![CDATA[上篇讲了如何使用模板创建一个低资源占用高效的linux虚拟机这篇我们讲一下如何利用这个虚拟机进行官方原版openwrt的编译，结合前段时间到手的新路由3，做一个简单的，支持802.11r的ap 创建非root用户由于openwrt不能使用root用户git和编译，首要任务是创建一个非root用户，用来进行git和编译首先，我们进入控制台打开root远程登录（确保更好的使用体验） 1234567891011sudo nano /etc/ssh/sshd_config 找到下面相关配置：# Authentication: #LoginGraceTime 120 #PermitRootLogin prohibit-password #StrictModes yes 更改为：# Authentication: #LoginGraceTime 120 PermitRootLogin yes #StrictModes yes 保存退出重启ubuntu 1reboot 然后就可以使用shell工具远程登录ubuntu虚拟机了怎么登录我就不细说了，win下用putty或者xshel，我是mac，直接用终端登录查看一下时间 1date 发现时间不对，是由于时区的缘故，我们使用以下命令把时区设置到上海 1timedatectl set-timezone Asia/Shanghai 重新查看一下时间，已经正确把源地址更换到国内 123456789nano /etc/apt/sources.list#把deb http://archive.ubuntu.com/ubuntu cosmic main restricted universe multiversedeb http://archive.ubuntu.com/ubuntu cosmic-updates main restricted universe multiversedeb http://archive.ubuntu.com/ubuntu cosmic-security main restricted universe multiverse#更换为deb http://mirrors.aliyun.com/ubuntu cosmic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu cosmic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu cosmic-security main restricted universe multiverse 更新一下系统 1sudo apt-get update &amp;&amp; sudo apt-get upgrade -y 创建用户 1adduser x #创建一个叫做x的用户,会要求你输入密码，然后填一些资料，资料可以直接会车跳过 赋予新用户root权限 1234nano /etc/sudoers #打开文件#在 root ALL=(ALL:ALL) ALL 下面添加x ALL=(ALL:ALL) ALL 保存退出，然后重启ubuntu,使用新用户登录 编译openwrt上回我们说编译原版openwrt，考虑了一下，还是教大家用lean的源码进行编译，因为功能更多更全，官方原版的只要换git地址就能一样编译。首先我们使用shell工具登录ubuntu,推荐使用xsell和putty。首先我们确保自己使用新建的用户登录，然后回到home目录下 123sudo apt-get -y install build-essential asciidoc binutils bzip2 gawk gettext git libncurses5-dev libz-dev patch unzip zlib1g-dev lib32gcc1 libc6-dev-i386 subversion flex uglifyjs git-core gcc-multilib p7zip p7zip-full msmtp libssl-dev texinfo libglib2.0-dev xmlto qemu-utils upx libelf-dev autoconf automake libtool autopoint#安装依赖cd #回到home目录 Lean源码地址下载git包（可能速度会比较慢，建议出国） 1git clone https://github.com/coolsnowwolf/lede.git #如果要编译官方openwrt 地址换成 https://www.github.com/openwrt/openwrt 下载完成后会在 1/home/x/lede 目录下 1cd /home/x/lede 源码插件(脚本等)更新并安装 12./scripts/feeds update -a ./scripts/feeds install -a 输入make menuconfig进行配置编辑我是新路由3配置按下图设置，其他软件包在Luci→Applications中设置插件的一些说明 LuCI Applications luci-app-accesscontrol 访问时间控制LuCI Applications luci-app-adblock ADB广告过滤LuCI Applications luci-app-adbyby-plus 广告屏蔽大师Plus +LuCI Applications luci-app-advanced-reboot 高级重启LuCI Applications luci-app-ahcp 支持AHCPdLuCI Applications luci-app-aliddns 阿里DDNS客户端LuCI Applications luci-app-amule aMule是一个跨平台的ED2K/KAD客户端 P2P电驴下载LuCI Applications luci-app-aria2 Aria2下载LuCI Applications luci-app-arpbind IP/MAC绑定LuCI Applications luci-app-asterisk 支持Asterisk电话服务器LuCI Applications luci-app-attendedsysupgrade 固件更新升级相关LuCI Applications luci-app-autoreboot 支持计划重启LuCI Applications luci-app-bcp38 BCP38网络入口过滤(不确定)LuCI Applications luci-app-bird4 Bird4服务(未知)LuCI Applications luci-app-bird6 Bird6服务(未知)LuCI Applications luci-app-bmx6 BMX6路由协议LuCI Applications luci-app-bmx7 BMX7路由协议LuCI Applications luci-app-cjdns 加密IPV6网络相关LuCI Applications luci-app-caldav 联系人LuCI Applications luci-app-clamav ClamAV杀毒软件LuCI Applications luci-app-commands Shell命令模块LuCI Applications luci-app-cshark CloudShark捕获工具LuCI Applications luci-app-ddns 动态域名 DNSLuCI Applications luci-app-diag-core core诊断工具LuCI Applications luci-app-dnscrypt-proxy DNSCrypt解决DNS污染LuCI Applications luci-app-dnsforwarder DNSForwarder防DNS污染LuCI Applications luci-app-dnspod DNSPodLuCI Applications luci-app-dump1090 民航无线频率(不确定)LuCI Applications luci-app-dynapoint DynaPoint(未知)LuCI Applications luci-app-e2guardian Web内容过滤器LuCI Applications luci-app-filetransfer 文件传输LuCI Applications luci-app-firewall 添加防火墙LuCI Applications luci-app-freifunk-diagnostics freifunk组件 诊断(未知)LuCI Applications luci-app-freifunk-policyrouting freifunk组件 策略路由(未知)LuCI Applications luci-app-freifunk-widgets freifunk组件 Widgets(未知)LuCI Applications luci-app-frpc 内网穿透 FrpLuCI Applications luci-app-fwknopd Firewall Knock Operator服务器LuCI Applications luci-app-guest-wifi WiFi访客网络LuCI Applications luci-app-hd-idle 硬盘休眠LuCI Applications luci-app-hnet Homenet Status家庭网络控制协议LuCI Applications luci-app-ipsec-vpnd VPN服务器 IPSecLuCI Applications luci-app-lxc LXC容器管理LuCI Applications luci-app-meshwizard 网络设置向导LuCI Applications luci-app-minidlna 完全兼容DLNA / UPnP-AV客户端的服务器软件LuCI Applications luci-app-mjpg-streamer 兼容Linux-UVC的摄像头程序LuCI Applications luci-app-mwan3 MWAN负载均衡LuCI Applications luci-app-mwan3helper MWAN3分流助手LuCI Applications luci-app-n2n_v2 N2N 内网穿透 N2N v2 VPN服务LuCI Applications luci-app-nlbwmon 网络带宽监视器LuCI Applications luci-app-noddos NodDOS Clients 阻止DDoS攻击LuCI Applications luci-app-ntpc NTP时间同步服务器LuCI Applications luci-app-ocserv OpenConnect VPN服务LuCI Applications luci-app-olsr OLSR配置和状态模块LuCI Applications luci-app-olsr-services OLSR服务器LuCI Applications luci-app-olsr-viz OLSR可视化LuCI Applications luci-app-openvpn OpenVPN客户端LuCI Applications luci-app-openvpn-server 易于使用的 OpenVPN 服务器 Web-UILuCI Applications luci-app-p910nd 打印服务器模块LuCI Applications luci-app-pagekitec Pagekite 内网穿透客户端LuCI Applications luci-app-polipo Polipo 是一个小型且快速的网页缓存代理。LuCI Applications luci-app-pppoe-relay PPPoE NAT穿透 点对点协议（PPP）LuCI Applications luci-app-pptp-server VPN服务器 PPTPLuCI Applications luci-app-privoxy Privoxy网络代理（带过滤无缓存）LuCI Applications luci-app-qos 流量服务质量(QoS)流控LuCI Applications luci-app-radicale CalDAV/CardDAV同步工具LuCI Applications luci-app-ramfree 释放内存LuCI Applications luci-app-rp-pppoe-server Roaring Penguin PPPoE Server 服务器LuCI Applications luci-app-samba 网络共享(samba)LuCI Applications luci-app-samba4 网络共享(samba4)LuCI Applications luci-app-sfe Turbo ACC网络加速(开启Fast Path转发加速)LuCI Applications luci-app-shadowsocks-libev SS-libev服务端LuCI Applications luci-app-shairplay 支持AirPlay功能LuCI Applications luci-app-siitwizard SIIT配置向导 SIIT-WizzardLuCI Applications luci-app-simple-adblock 简单的广告拦截LuCI Applications luci-app-splash Client-Splash是无线MESH网络的一个热点认证系统LuCI Applications luci-app-sqm 流量智能队列管理(QOS)LuCI Applications luci-app-squid Squid代理服务器LuCI Applications luci-app-ssr-plus 出国 luci-app-ssr-plus Include Shadowsocks New Versiong 新SS代理 Include V2ray V2Ray透明代理 Include Kcptun Kcptun代理 Include ShadowsocksR Server 出国 Include ShadowsocksR Socks and Tunnel SSR代理LuCI Applications luci-app-ssr-pro 出国LuCI Applications luci-app-ssrserver-python ShadowsocksR Python服务器LuCI Applications luci-app-statistics 流量监控工具LuCI Applications luci-app-syncdial 多拨虚拟WAN(原macvlan)LuCI Applications luci-app-tinyproxy Tinyproxy是 HTTP(S)代理服务器LuCI Applications luci-app-transmission BT下载工具LuCI Applications luci-app-travelmate 旅行路由器LuCI Applications luci-app-ttyd 网页终端命令行LuCI Applications luci-app-udpxy udpxy做组播服务器LuCI Applications luci-app-uhttpd uHTTPd Web服务器LuCI Applications luci-app-unbound Unbound DNS解析器LuCI Applications luci-app-upnp 通用即插即用UPnP(端口自动转发)LuCI Applications luci-app-usb-printer USB 打印服务器LuCI Applications luci-app-v2ray-pro V2Ray透明代理LuCI Applications luci-app-vlmcsd KMS服务器（激活工具）LuCI Applications luci-app-vnstat vnStat网络监控（图表）LuCI Applications luci-app-vpnbypass VPN BypassWebUI 绕过VPN设置LuCI Applications luci-app-vsftpd FTP服务器LuCI Applications luci-app-watchcat 断网检测功能与定时重启LuCI Applications luci-app-webadmin Web管理LuCI Applications luci-app-wifischedule WiFi 计划LuCI Applications luci-app-wireguard VPN服务器 WireGuard状态LuCI Applications luci-app-wireless-regdb WiFi无线LuCI Applications luci-app-wol WOL网络唤醒LuCI Applications luci-app-wrtbwmon 实时流量监测LuCI Applications luci-app-xlnetacc 迅雷快鸟LuCI Applications luci-app-zerotier 内网穿透 ZeroTier 配置完成后按几次ESC退出 最后输入Y确认保存配置然后输入make download进行插件包的预下载，时间会比较长，建议出国下载完成后输入 1make -j1 V=s #-j1 后面是线程数。第一次编译推荐用单线程 然后等待编译完成即可编译完成后的固件会在/home/x/lede/bin/targets下的一个文件夹里，可使用winscp等工具下载下来]]></content>
      <tags>
        <tag>proxmox ve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于ProXmoX VE的虚拟化家庭服务器（篇四）—利用模板创建linux虚拟机]]></title>
    <url>%2F%E5%88%9B%E5%BB%BAlinux%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[前几篇我们讲了这么如何安装pve以及软路由等虚拟机，今天我们来讲一下如何使用模板来创建一个linux虚拟机。 1.下载linux模板我们找到local存储或者我们上次添加的OS目录 点开后他应该会包含有容器模板选项，如下图我们选择内容点击模板这里我们选择ubuntu-18.10点击下载由于下载服务器在国外，出国可以获得更好的下载速度（人不出国网出国）这时候可以建linux虚拟机了 2.创建虚拟机点击创建CT设置主机名和root密码,注意去掉无特权容器的勾（如果要使用nfs的话）然后下一步选择模板，下一步设置磁盘大小，下一步设置cpu数量（其实就是使用的cpu资源比例）设置内存大小，我设置到2g设置网络，注意桥接的接口，注意ip，默认静态，需要手动设置，或者使用dhcp获取设置dns，建议在主机设置dns后使用默认设置确认配置，完成显示ok表示创建成功如果要使用nfs挂载到这里打开，否则死活挂载不了然后就可以启动了由于使用的是半虚拟化，加载的是proxmox宿主机的内核，启动速度超快，占用资源也非常小，下篇我们讲一下如何使用ubuntu虚拟机编译原版openwrt固件]]></content>
      <tags>
        <tag>proxmox ve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件与工具推荐]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[预览软件：QuickLookWindows快速查看工具。按空格快速预览。截图：Snipaste按F1开始剪切，然后按F3将其粘贴为浮动窗口，浮动窗口还支持文本。除了贴图功能外，Snipaste 作为截图工具也非常强大，完全可以满足日常截图需求。 解压：Bandizip好多人推荐这个，亲自试用了下，果然比7z要好用些。果断更换推荐。这个还支持解压前预览。 本地视频播放：PotPlayer功能强大的播放器，十个推荐，九个有它。安装时完成时，推荐下载编码器。 看图软件：Honeyview这软件和bandizip是一家的。软件界面挺清爽的。打开图片的速度好快。还有就是不用解压就能看压缩包图片。看漫画会很方便。 IOS设备管理：iMazing传输和保存音乐、消息、文件和数据。安全备份任何 iPhone、iPad 或 iPod touch。iMazing 功能强大、易于使用，称得上是 Mac 和 PC 上最好的 iOS 设备管理器。最后这句说的没错。 文件搜索 everythingEverything 是速度最快的文件名搜索工具 文件搜索 Listary可是比everything更强大，有很多插件，缺点是搜索界面较小，没有everything全面 字幕调整 Aegisub镜像刻录 rufus公众号运营工具 壹伴主要有两点最吸引我的地方：融合进公众号后台，不需要跳转网页；强大的数据分析管理功能；它不需要像其他编辑器那样需要完成编辑之后再同步或者复制到微信公众号后台，能够让微信公众号编辑更加便捷高效。此外，强大的数据分析管理功能能够让30多项数据清晰可见，对自己的运营情况更加了如指掌。此外，壹伴还有连续格式刷、导入word、插入代码、图片编辑美化等便捷工具，大大提高公众号编辑效率。 文件归类软件 DropIt文字识别 天若OCRword排版插件 小恐龙公文排版助手]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用hexo+github+coding（腾讯云开发平台）架设个人博客]]></title>
    <url>%2F%E5%88%A9%E7%94%A8hexo%2Bgithub%2Bcoding%E6%9E%B6%E8%AE%BE%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[一、Hexo介绍初次了解到hexo是在骆昊大神的python教程《Python - 100天从新手到大师》,然后就去百度以及官网上看了下资料，发现这是一个非常轻量、简洁、部署方式非常“程序员”的一个个人博客。 Hexo 的中文官网：http://hexo.io/zh-cn/ 作者 Tommy Chen：https://zespia.tw/ 二、部署部署分以下几步走 搭建node环境 搭建git环境 安装hexo以及GitHub、coding设置 个人域名设置 由于我是部署在CentOS 7 上的，所以一下内容均以CentOS 7 作为平台 2.1 搭建node环境CentOS下非常简单只要输入以下命令就可以自动安装node以及npm（npm是node的包管理工具） 12yum install nodejsyum install npm 可以使用以下命令查看是否安装成功 12node -vnpm -v npm加速 1npm config set registry https://registry.npm.taobao.org 2.2 搭建git环境和node一样简单 1yum install git 使用以下命令查看版本 1git --version 2.3 安装hexo以及GitHub、coding设置2.3.1 安装hexo首先CD到home目录下, 1cd /home 使用以下命令安装hexo（安装过程中会自动创建一个blog文件夹路径为/home/blog） 1234npm install hexo-cli -g hexo init blogcd blognpm install node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 _config.yml: 博客的配置文件 12hexo g #生成静态页面hexo server #启动本地服务 2.3.2 创建github仓库首先注册一个GitHub账户注册完成登录后，在github.com中看到一个new，新建仓库 创建一个和你用户名相同的仓库，后面加.github.io,&lt;yourname.github.io&gt;这样在部署到GitHub page的时候等于网页在你的根目录,这里因为我已经创建过了，所以是红色叹号 点击Create repository。 2.3.3 创建coding仓库创建coding仓库的时候有个小坑，就是coding个人仓库业务好像被腾讯收购了，现在进入coding个人仓库要从 腾讯云开发者平台：https://dev.tencent.com/ 进入 绑定邮箱时尽量使用和github相同的邮箱账户 从右上角的＋号-项目 新建仓库 项目名称使用&lt;yourname.coding.me&gt;创建，同样是为了pages服务方便 点击新建项目 2.3.4 生成ssh key 添加到github和coding回到ContOS 7 中 12git config --global user.name "yourname"git config --global user.email "youremail" 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。 可以用以下两条命令检查git的用户名和密码 12git config user.namegit config user.email 使用以下命令生成ssh key 1ssh-keygen -t rsa -C "youremail" id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去。 coding操作类似 绑定完成后可以使用以下命令来分别测试是否可以正确连接 12ssh -T git@github.comssh -T git@e.coding.net 安装git插件 1npm install hexo-deployer-git --save 如果测试无误，就可以使用以下命令来部署到github和coding上了 1234hexo clean #做以下清理hexo g #生成页面hexo d #部署到git仓库#hexo d --g #简化命令 以上命令需要在blog目录下进行 2.3.5 个人域名设置我这里使用dnspod域名解析做例子，dnspod搭配freenom免费域名非常好用 添加两个CNAME记录，记录值分别填两个git仓库的静态域名 同时，在hexo的./blog/source目录下创建一个CNAME文件，内容为你的域名，比如我的就是 1clegea.cf 填写完成后保存，重新部署一下，过一会应该就能使用你自己的个人域名访问了 三、更换主题及一些优化设置博客已经搭建完成，不过不是很好看，这时候我们就可以安装来进行一些美化。 官方主题库：https://hexo.io/themes/ 这里我推荐NexT主题，非常简洁，符合当下审美 NexT官方文档：http://theme-next.iissnan.com/ 我们直接git NexT的最新版本，使用以下命令 12cd /home/blog #确保在blog目录下git clone https://github.com/theme-next/hexo-theme-next themes/next 修改blog目录下的 _config.yml文件启用next 简书上有一篇非常详细的next主题的配置文件说明:Hexo的Next主题详细配置使首页使用缩略模式进入hexo博客项目的themes/next目录用文本编辑器打开_config.yml文件搜索”auto_excerpt”,找到如下部分： 12345678#Automatically Excerpt. Not recommand.#Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 把enable改为对应的false改为true，然后hexo d -g使用本地图片 确认_config.yml 中有 post_asset_folder:true。 在hexo的目录下执行1npm install https://github.com/7ym0n/hexo-asset-image --save 打开搜索功能 安装搜索：在Hexo的根目录下，打开命令可执行窗口，执行如下命令： 1npm install hexo-generator-searchdb --save 全局配置文件_config.yml，新增如下内容： 12345search: path: search.xml field: post format: html limit: 10000 hexo主题配置文件（\themes\next_config.yml），修改local_search的enable为true： 1234567local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用proxmox ve 搭建家庭服务器]]></title>
    <url>%2F%E5%88%A9%E7%94%A8proxmox%E6%90%AD%E5%BB%BA%E5%AE%B6%E5%BA%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[ProXmoX VE 介绍Proxmox VE是一款套开源的虚拟化管理软件，用户可通过网页的方式来管理服务器上使用 kvm 以及 lxc 技术运行的虚拟机。同时提供了一些先进功能的支持，如集群、HA等。PVE虽然是开源，却是由一个商业公司在运营、更新以及维护。基础安装完工 ProXmoX VE 安装基础准备 16G以上U盘一个(非必须，这个U盘是用来安装PROXMOX的，也可以直接装硬盘上，GEN8比较特殊，使用U盘引导比较方便，所以我安装在U盘上)；4G以上U盘一个； 支持虚拟化技术的CPU； 如果要虚拟软路由，需要有2个网口以上，最好千兆。 安装过程首先去proxmox下载安装包，目前最新版本是5.2-1，推荐使用种子下载，速度会比较快，下载完成后务必使用使用工具进行SHA256校验，防止下载错误然后使用软碟通或者rufus之类的工具把下载的ISO文件刻录进4G的U盘（本人使用GEN8的ILO4远程安装，有GEN8的朋友应该知道咋弄）。接着把4GU盘和16GU盘插入电脑，BIOS中开启虚拟化支持（具体方法百度，BIOS太多，我就不放图了），一个网口接入路由，使用4GU盘引导启动很快就会进入安装界面。此处选择第一项回车，稍微等待一会，进入下图界面选择 I agree这里选择你要安装的的硬盘或者U盘，选定后点击Next这里一般会默认china，如果没有那就输入china，其他默认，点击Next输入两遍管理密码并输入邮箱，点击Next这里注意，查看一下是不是你局域网的网段，如果不是，很可能和路由之间网络不通，另外，Hostname这项的格式需为.，默认的是无法下一步的，我这里使用PVE.LEN，点击next，等待安装完成出现如上界面时，说明安装已经完成，点击reboot，重启过程中拔掉U盘，然后设置为你安装的U盘或者硬盘启动，等待重启完成。出现如上界面时说明安装完成了,用另外一台电脑在浏览器中输入上面的地址进行访问language选择chinese就可以中文访问啦，用户名输入root，密码为刚才安装时候输的两遍管理密码 ProXmoX VE 初始配置 由于proxmox一些功能是需要付费订阅的，虽然可以免费使用，但是每次登陆时候都会弹出如上让你订阅的通知，比较烦，我们这里通过技术手段把它屏蔽掉。首先点击确定把它关掉，然后通过winscp打开以下文件 1/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js 或者直接在web界面的shell中使用vi、nano等工具编辑找到 1if (data.status!==&apos;Active&apos;) 替换为 1if (false) 这条位置比较靠后，大约在800行，替换完成后保存文件，注销登陆，清理浏览器缓存，再次登陆，发现已经不再弹窗让你订阅啦。接下来下来我们更新一下proxomx的软件，proxmox的底层毕竟是个debian系统，刚安装还是要更新一下的，在shell中输入aptupdate &amp;&amp; apt dist-upgrade，回车，发现报错无法更新，查看官方文档发现需要更改一些设置，在shell输入 1rm -f /etc/apt/sources.list.d/pve-enterprise.list #移除原更新原地址 添加新的原地址 1echo "deb http://download.proxmox.com/debian/pve stretch pve-no-subscription" &gt; /etc/apt/sources.list.d/pve-install-repo.list 下载秘钥 1wget http://download.proxmox.com/debian/proxmox-ve-release-5.x.gpg -O /etc/apt/trusted.gpg.d/proxmox-ve-release-5.x.gpg 更新 1apt update &amp;&amp; apt dist-upgrade 等待更新完成，输入 1reboot 重启服务器 ProXmoX VE 磁盘映射如果你的proxmox是直接安装在硬盘上的，那已经可以正常使用了，如果你和我一样是安装在U盘的，因为U盘空间比较小，需要弄个硬盘用来安装虚拟机在磁盘中看下哪个是你要挂载的硬盘，，我这里需要挂载的设备目录为/dev/sdb在shell中输入 1mkdir /mnt/sdb 创建sdb文件夹用来给磁盘挂载输入fdisk /dev/sdb管理这个硬盘，给它分区输入n新建分区输入p建立主分区输入1创建一个分区这里是让输入这个分区的扇区起始位置，我们选择默认，直接回车分区的扇区结束位置，默认，直接回车，到此就分区完成了，我们输入p查看一下分区已经完成，目录为/dev/sdb1输入w，保存并退出fdisk工具输入 1mkfs -t ext4 /dev/sdb1 格式化一下输入 1mount /dev/sdb1 /mnt/sdb 进行挂载为了使proxmox可以开机自动挂载我们输入 123456nano /etc/fstab``` 编辑一下这个文件，在最后追加```sh/dev/sdb1 /mnt/sdb ext4 defaults 0 0 保存退出这样就不用每次开机mount了然后依次点击数据中心-存储-添加-目录ID随意，目录输入刚才挂载的目录，内容都选上，点添加，最后点OS查看一下是否正常识别]]></content>
      <tags>
        <tag>proxmox ve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁]]></title>
    <url>%2F%E8%9A%82%E8%9A%81%2F</url>
    <content type="text"><![CDATA[起因也不记得具体时间了，大约是一个月前，屋子里飞来一只小虫子，老婆呼喊着我去打死，我跑去一看，这不是一只婚飞的蚁后么（婚飞：蚁后未交配时是有翅膀的，飞出巢穴和雄蚁交配，交配完成后便会飞到一处挖个洞生下第一窝蚂蚁），立马拿出一个试管，堵上一半水，把它抓了起来，然后就放在一个角落里不管他了 7月26日今天拿出来一看，已经脱翅生了一堆卵了，看来是一只交配过的蚁后 8月12日又是十多天过去了，一看，已经有两个超小的蚂蚁出生了,看小蚂蚁屁股的样子，应该是种举腹蚁]]></content>
  </entry>
</search>
